<div id=toc></div>

# Table of Contents

- [cs.SE](#cs.SE) [Total: 10]
- [cs.DB](#cs.DB) [Total: 2]
- [cs.DC](#cs.DC) [Total: 3]


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [1] [Perceptual Self-Reflection in Agentic Physics Simulation Code Generation](https://arxiv.org/abs/2602.12311)
*Prashant Shende,Bradley Camburn*

Main category: cs.SE

TL;DR: 提出一个多智能体框架，通过自然语言描述生成物理模拟代码，采用感知自反思机制进行验证，显著优于单次生成方法。


<details>
  <summary>Details</summary>
Motivation: 解决传统代码测试中的"预言机鸿沟"问题——语法正确的代码可能产生物理上错误的行为，而传统测试无法检测这种问题。

Method: 使用四个专门智能体：自然语言解释器、技术需求生成器、带自动自校正的物理代码生成器、实现感知自反思的物理验证器。关键创新是感知验证，通过视觉语言模型分析渲染的动画帧而非直接检查代码结构。

Result: 在经典力学、流体动力学、热力学、电磁学、波物理、反应扩散系统和非物理数据可视化等七个领域评估，感知自反思架构相比单次生成基线有显著改进，多数测试场景达到目标物理精度阈值，系统具有鲁棒的管道稳定性，每次动画成本约0.20美元。

Conclusion: 将视觉模拟输出反馈给视觉语言模型进行迭代精炼，显著优于单次代码生成，展示了智能体AI支持工程工作流和物理数据生成管道的潜力。

Abstract: We present a multi-agent framework for generating physics simulation code from natural language descriptions, featuring a novel perceptual self-reflection mechanism for validation. The system employs four specialized agents: a natural language interpreter that converts user requests into physics-based descriptions; a technical requirements generator that produces scaled simulation parameters; a physics code generator with automated self-correction; and a physics validator that implements perceptual self-reflection. The key innovation is perceptual validation, which analyzes rendered animation frames using a vision-capable language model rather than inspecting code structure directly. This approach addresses the ``oracle gap'' where syntactically correct code produces physically incorrect behavior--a limitation that conventional testing cannot detect. We evaluate the system across seven domains including classical mechanics, fluid dynamics, thermodynamics, electromagnetics, wave physics, reaction-diffusion systems, and non-physics data visualization. The perceptual self-reflection architecture demonstrates substantial improvement over single-shot generation baselines, with the majority of tested scenarios achieving target physics accuracy thresholds. The system exhibits robust pipeline stability with consistent code self-correction capability, operating at approximately \$0.20 per animation. These results validate our hypothesis that feeding visual simulation outputs back to a vision-language model for iterative refinement significantly outperforms single-shot code generation for physics simulation tasks and highlights the potential of agentic AI to support engineering workflows and physics data generation pipelines.

</details>


### [2] [SHAPR: A Solo Human-Centred and AI-Assisted Practice Framework for Research Software Development](https://arxiv.org/abs/2602.12443)
*Ka Ching Chan*

Main category: cs.SE

TL;DR: SHAPR框架：为独立研究人员在AI辅助研究软件开发中提供实践指导，补充行动设计研究方法


<details>
  <summary>Details</summary>
Motivation: 随着研究软件成为高等教育研究中的重要工具，独立研究人员越来越多地开发软件制品作为研究方法。同时，生成式人工智能正在重塑开发实践，既提供强大辅助，又带来问责、反思和方法严谨性的新挑战。虽然行动设计研究为研究社会技术制品提供了基础，但缺乏对独立、AI辅助研究软件开发日常实践的具体指导。

Method: 提出SHAPR框架（独立、以人为本、AI辅助实践），作为实践层面的操作框架，将行动设计研究的高级原则转化为当代研究背景下的可操作指导。SHAPR通过明确角色、制品、反思实践和轻量级治理机制，支持行动设计研究的构建-干预-评估循环。

Result: SHAPR框架本身作为主要设计制品和分析单元，通过反思性分析评估其内部一致性、与行动设计研究原则的契合度以及对独立研究实践的适用性。该框架将研究软件开发、人机协作和反思学习明确联系起来。

Conclusion: SHAPR框架为独立研究人员的AI辅助软件开发提供了实践指导，支持知识生产和高等教育研究人员培训，为人机协作中的问责和学习提供了系统方法。

Abstract: Research software has become a central vehicle for inquiry and learning in many Higher Degree Research (HDR) contexts, where solo researchers increasingly develop software-based artefacts as part of their research methodology. At the same time, generative artificial intelligence is reshaping development practice, offering powerful forms of assistance while introducing new challenges for accountability, reflection, and methodological rigour. Although Action Design Research (ADR) provides a well-established foundation for studying and constructing socio-technical artefacts, it offers limited guidance on how its principles can be operationalised in the day-to-day practice of solo, AI-assisted research software development. This paper proposes the SHAPR framework (Solo, Human-centred, AI-assisted PRactice) as a practice-level operational framework that complements ADR by translating its high-level principles into actionable guidance for contemporary research contexts. SHAPR supports the enactment of ADR Building-Intervention-Evaluation cycles by making explicit the roles, artefacts, reflective practices, and lightweight governance mechanisms required to sustain human accountability and learning in AI-assisted development. The contribution of the paper is conceptual: SHAPR itself is treated as the primary design artefact and unit of analysis and is evaluated formatively through reflective analysis of its internal coherence, alignment with ADR principles, and applicability to solo research practice. By explicitly linking research software development, Human-AI collaboration, and reflective learning, this study contributes to broader discussions on how SHAPR can support both knowledge production and HDR researcher training.

</details>


### [3] [Favia: Forensic Agent for Vulnerability-fix Identification and Analysis](https://arxiv.org/abs/2602.12500)
*André Storhaug,Jiamou Sun,Jingyue Li*

Main category: cs.SE

TL;DR: Favia是一个基于智能体的漏洞修复提交识别框架，通过候选排序和深度语义推理相结合的方法，在真实世界大规模代码库中准确识别CVE相关的修复提交。


<details>
  <summary>Details</summary>
Motivation: 现有自动化方法（包括传统机器学习和大语言模型方法）在识别漏洞修复提交时存在精度-召回率权衡问题，且评估方法低估了真实世界的难度，因为候选提交通常已经是安全相关且高度相似的。

Method: Favia采用法医式、基于智能体的框架：1）高效排序阶段缩小提交搜索空间；2）使用ReAct-based LLM智能体进行深度迭代语义推理，为智能体提供预提交仓库环境和专用工具，使其能够定位漏洞组件、导航代码库，并建立代码变更与漏洞根本原因之间的因果对齐。

Result: 在CVEVC数据集（包含3,708个真实仓库的800多万次提交）上评估，Favia在真实候选选择下始终优于最先进的传统和LLM基线方法，实现了最强的精度-召回率权衡和最高的F1分数。

Conclusion: Favia通过结合可扩展的候选排序与深度迭代语义推理，能够稳健地识别间接、多文件和非平凡的修复，这些修复通常逃过单次或基于相似性的方法，为大规模安全软件维护提供了有效的解决方案。

Abstract: Identifying vulnerability-fixing commits corresponding to disclosed CVEs is essential for secure software maintenance but remains challenging at scale, as large repositories contain millions of commits of which only a small fraction address security issues. Existing automated approaches, including traditional machine learning techniques and recent large language model (LLM)-based methods, often suffer from poor precision-recall trade-offs. Frequently evaluated on randomly sampled commits, we uncover that they are substantially underestimating real-world difficulty, where candidate commits are already security-relevant and highly similar. We propose Favia, a forensic, agent-based framework for vulnerability-fix identification that combines scalable candidate ranking with deep and iterative semantic reasoning. Favia first employs an efficient ranking stage to narrow the search space of commits. Each commit is then rigorously evaluated using a ReAct-based LLM agent. By providing the agent with a pre-commit repository as environment, along with specialized tools, the agent tries to localize vulnerable components, navigates the codebase, and establishes causal alignment between code changes and vulnerability root causes. This evidence-driven process enables robust identification of indirect, multi-file, and non-trivial fixes that elude single-pass or similarity-based methods. We evaluate Favia on CVEVC, a large-scale dataset we made that comprises over 8 million commits from 3,708 real-world repositories, and show that it consistently outperforms state-of-the-art traditional and LLM-based baselines under realistic candidate selection, achieving the strongest precision-recall trade-offs and highest F1-scores.

</details>


### [4] [Reconciling Complexity and Simplicity in the Business Model Canvas Design Through Metamodelling and Domain-Specific Modelling](https://arxiv.org/abs/2602.12721)
*Nordine Benkeltoum*

Main category: cs.SE

TL;DR: 提出基于UML的BMC元模型和DSML工具，通过形式化定义组件关系（支持、决定、影响）来平衡建模严谨性与实用性


<details>
  <summary>Details</summary>
Motivation: 虽然BMC被广泛采用，但在形式化建模方面存在挑战，特别是组件间关系的明确规范与保持BMC简单性之间的张力

Method: 采用设计科学研究方法，基于V4框架，使用UML开发BMC元模型和专门的DSML工具

Result: 提出的元模型将BMC关系归纳为三种核心类型，形式化规范显著提高了BMC表示的可解释性和一致性

Conclusion: 元模型和工具为开发DSML-based BMC工具提供了严谨且可用的基础，能够将BMC系统集成到软件和企业建模环境中，连接业务建模与企业架构实践

Abstract: This article introduces a metamodel for the Business Model Canvas (BMC) using the Unified Modelling Language (UML), together with a dedicated Domain-Specific Modelling Language (DSML) tool. Although the BMC is widely adopted by both practitioners and scholars, significant challenges remain in formally modelling business models, particularly with regard to explicit specification of inter-component relationships, while preserving the simplicity that characterises the BMC. Addressing this tension between modelling rigour and practical relevance, this research adopts a Design Science Research approach to formally specify relationships among BMC components and to strengthen their theoretical grounding through an adaptation of the V 4 framework. The proposed metamodel consolidates BMC relationships into three core types: supports, determines, and affects, providing explicit semantics while remaining accessible to end users through graphical tooling. The findings highlight that formally specifying relationships significantly improves the interpretability and consistency of BMC representations. The proposed metamodel and tool offer a rigorous yet usable foundation for developing DSML-based BMC tools and for enabling systematic integration of the BMC into widely used software and enterprise modelling environments, thereby bridging business modelling and enterprise architecture practices for both academics and practitioners.

</details>


### [5] [FuncDroid: Towards Inter-Functional Flows for Comprehensive Mobile App GUI Testing](https://arxiv.org/abs/2602.12834)
*Jinlong He,Changwei Xia,Binru Huang,Jiwei Yan,Jun Yan,Jian Zhang*

Main category: cs.SE

TL;DR: FuncDroid：基于功能流图的GUI测试方法，通过长短期视图指导测试过程，显著提升覆盖率和深层次功能交互bug检测能力


<details>
  <summary>Details</summary>
Motivation: 现有GUI测试方法主要关注单一功能测试，忽视了功能间的交互行为，难以发现隐藏在跨功能交互中的深层次bug。随着移动应用功能日益复杂和迭代加速，确保高可靠性面临重大挑战。

Method: 首先设计功能流图（FFG）行为模型，明确捕捉应用的功能单元及其跨功能交互。基于FFG引入跨功能流导向的GUI测试方法，通过长短期视图指导的测试过程，结合两种互补的测试生成视图，自适应细化功能边界，系统探索不同触发条件下的跨功能流。

Result: 在50个可复现崩溃bug的基准测试和52个流行商业应用上评估，FuncDroid在覆盖率上比现有最佳方法提升28%，bug检测数量提升107%。在商业应用中成功发现18个先前未知的非崩溃功能bug。

Conclusion: FuncDroid通过功能流图建模和长短期视图指导的测试方法，有效解决了跨功能交互测试的挑战，显著提升了GUI测试的覆盖率和深层次bug检测能力，具有实际应用价值。

Abstract: As mobile application (app) functionalities grow increasingly complex and their iterations accelerate, ensuring high reliability presents significant challenges. While functionality-oriented GUI testing has attracted growing research attention, existing approaches largely overlook interactions across functionalities, making them ineffective at uncovering deep bugs hidden in inter-functional behaviors. To fill this gap, we first design a Functional Flow Graph (FFG), a behavioral model that explicitly captures an app's functional units and their inter-functional interactions. Based on the FFG, we further introduce an inter-functional-flow-oriented GUI testing approach with the dual goals of precise model construction and deep bug detection. This approach is realized through a long-short-term-view-guided testing process. By combining two complementary test-generation views, it can adaptively refine functional boundaries and systematically explore inter-functional flows under diverse triggering conditions. We implement our approach in a tool called FuncDroid, and evaluate it on two benchmarks: (1) a widely-used open-source benchmark with 50 reproducible crash bugs and (2) a diverse set of 52 popular commercial apps. Experimental results demonstrate that FuncDroid significantly outperforms state-of-the-art baselines in both coverage (+28%) and bug detection number (+107%). Moreover, FuncDroid successfully uncovers 18 previously unknown non-crash functional bugs in commercial apps, confirming its practical effectiveness.

</details>


### [6] [A Microservice-Based Platform for Sustainable and Intelligent SLO Fulfilment and Service Management](https://arxiv.org/abs/2602.12875)
*Juan Luis Herrera,Daniel Wang,Schahram Dustdar*

Main category: cs.SE

TL;DR: CASCA是一个开源微服务架构平台，帮助计算连续体提供商在保护开发者隐私的同时，通过运行时服务重配置来满足性能和可持续性SLO


<details>
  <summary>Details</summary>
Motivation: 微服务架构在计算连续体部署中面临性能和可持续性SLO平衡的挑战，同时需要保护开发者隐私，现有解决方案难以同时满足这些需求

Method: 开发了CASCA平台，采用微服务架构设计，允许CC提供商在运行时重新配置服务以满足SLO，同时通过架构设计保护开发者隐私

Result: 在真实CC测试环境中评估了CASCA，使用Bash、Rust和Python实现的决策系统成功重新配置了媒体流服务，且隐私保护未受影响

Conclusion: CASCA是一个高度可重用、可分发、易于使用的平台，能够有效解决计算连续体中微服务应用的SLO管理和隐私保护问题

Abstract: The Microservices Architecture (MSA) design pattern has become a staple for modern applications, allowing functionalities to be divided across fine-grained microservices, fostering reusability, distribution, and interoperability. As MSA-based applications are deployed to the Computing Continuum (CC), meeting their Service Level Objectives (SLOs) becomes a challenge. Trading off performance and sustainability SLOs is especially challenging. This challenge can be addressed with intelligent decision systems, able to reconfigure the services during runtime to meet the SLOs. However, developing these agents while adhering to the MSA pattern is complex, especially because CC providers, who have key know-how and information to fulfill these SLOs, must comply with the privacy requirements of application developers. This work presents the Carbon-Aware SLO and Control plAtform (CASCA), an open-source MSA-based platform that allows CC providers to reconfigure services and fulfill their SLOs while maintaining the privacy of developers. CASCA is architected to be highly reusable, distributable, and easy to use, extend, and modify. CASCA has been evaluated in a real CC testbed for a media streaming service, where decision systems implemented in Bash, Rust, and Python successfully reconfigured the service, unaffected by upholding privacy.

</details>


### [7] [The Influence of Code Smells in Efferent Neighbors on Class Stability](https://arxiv.org/abs/2602.12950)
*Zushuai Zhang,Elliott Wen,Ewan Tempero*

Main category: cs.SE

TL;DR: 研究代码异味在依赖类中的存在如何影响类稳定性，考虑异味相互关联和交互作用


<details>
  <summary>Details</summary>
Motivation: 代码不稳定性对软件维护至关重要，但现有研究主要关注类自身的代码异味，忽略了依赖类中异味的涟漪效应和异味间的相互关联与交互作用

Method: 从100个顶级GitHub项目中挖掘一年的提交历史，检测代码异味和静态依赖关系，确定代码异味的相互关联和交互作用，将这些因素建模为类稳定性的预测因子

Result: 论文未在摘要中提供具体结果，但研究框架已建立，旨在量化代码异味在依赖类中的存在对类稳定性的影响

Conclusion: 需要系统研究代码异味在依赖类中的存在、异味相互关联和交互作用对类稳定性的影响，以更全面地理解代码质量维护机制

Abstract: Understanding what drives code instability is essential for effective software maintenance, as unstable classes require larger or more frequent edits and increase the risk of unintended side effects. Although code smells are widely believed to harm maintainability, most prior stability studies examine only the smells within the class being modified. In practice, however, classes can change because their efferent neighbors (i.e., the classes they depend on) are modified due to ripple effects that propagate along static dependencies, even if the class itself is clean. Such ripple effects may be more severe when the efferent neighbor exhibits code smells. In addition, code smells rarely occur alone. They often appear together within a class or across classes connected by static dependencies, a phenomenon known as code smell interrelation. Such interrelation can lead to code smell interaction, where smells are directly connected through static dependencies and may further compound maintainability issues. However, the effect of code smell interrelation and interaction on code quality remains largely underexplored. Therefore, this study investigates whether the presence of code smells in a class's efferent neighbors affects its stability, considering the factor of code smell interrelation and interaction. To achieve this, we mine one year of commit history from 100 top-starred GitHub projects, detect code smells and static dependencies, determine code smell interrelation and interaction, and model these factors as predictors of class stability.

</details>


### [8] [Analysis of Asset Administration Shell-based Negotiation Processes for Scaling Applications](https://arxiv.org/abs/2602.13029)
*David Dietrich,Armin Lechler,Alexander Verl*

Main category: cs.SE

TL;DR: 本文研究主动式资产管理壳（AAS）在资产数量扩展时的协商效率，通过实验分析其性能限制、通信开销和可扩展性，为AAS的进一步开发和标准化提供参考。


<details>
  <summary>Details</summary>
Motivation: 当前AAS标准化主要关注子模型和安全以实现互操作数据访问，其主动行为仍处于概念阶段。现有研究仅针对有限数量的资产，缺乏对工业环境中大规模应用可扩展性的验证。

Method: 提出场景和评估标准，基于当前主动AAS架构开发可扩展实现，通过改变资产数量进行实验，分析消息负载等指标。

Result: 实验结果揭示了AAS协商机制在扩展时的性能限制、通信开销和适应性，显示随着资产数量增加会出现可扩展性挑战。

Conclusion: 研究结果为AAS的进一步开发和标准化提供了重要信息，特别是针对大规模工业应用中的主动协商机制的可扩展性改进。

Abstract: The proactive Asset Administration Shell (AAS) enables bidirectional communication between assets. It uses the Language for I4.0 Components in VDI/VDE 2193 to facilitate negotiations, such as allocating products to available production resources. This paper investigates the efficiency of the negotiation, based on criteria, such as message load, for applications with a scaling number of assets. Currently, the focus of AAS standardization is on submodels and their security to enable interoperable data access. Their proactive behavior remains conceptual and is still a subject of scientific research. Existing studies examine proactive AAS architecture examples with a limited number of assets, raising questions about their scalability in industrial environments. To analyze proactive AAS for scaling applications, a scenario and evaluation criteria are introduced. A scalable implementation is developed using current architectures for proactive AAS, upon which experiments are conducted with a varying number of assets. The results reveal the performance limitations, communication overhead, and adaptability of the AAS-based negotiation mechanism scaling. This information can improve the further development and standardization of the AAS.

</details>


### [9] [Automated Testing of Task-based Chatbots: How Far Are We?](https://arxiv.org/abs/2602.13072)
*Diego Clerissi,Elena Masserini,Daniela Micucci,Leonardo Mariani*

Main category: cs.SE

TL;DR: 对现有任务型聊天机器人测试技术进行确认性研究，评估其在真实GitHub项目上的有效性


<details>
  <summary>Details</summary>
Motivation: 随着聊天机器人日益普及，有效评估其质量变得至关重要。传统测试技术无法系统性地覆盖对话空间，而现有的聊天机器人专用测试技术虽然有所进步，但仍存在测试场景简单、断言机制薄弱等局限性。

Method: 进行确认性研究，评估最先进的聊天机器人测试技术在精选的GitHub任务型聊天机器人上的有效性。这些聊天机器人使用最流行的商业和开源平台开发。

Result: 论文未提供具体结果，但通过评估现有测试技术在真实项目上的表现来验证其局限性。

Conclusion: 需要进一步研究来改进聊天机器人测试技术，特别是增强测试场景的复杂性和断言机制的强度。

Abstract: Task-based chatbots are software, typically embedded in real-world applications, that assist users in completing tasks through a conversational interface. As chatbots are gaining popularity, effectively assessing their quality has become crucial. Whereas traditional testing techniques fail to systematically exercise the conversational space of chatbots, several approaches specifically targeting chatbots have emerged from both industry and research. Although these techniques have shown advancements over the years, they still exhibit limitations, such as simplicity of the generated test scenarios and weakness in implemented oracles. In this paper, we conduct a confirmatory study to investigate such limitations by evaluating the effectiveness of state-of-the-art chatbot testing techniques on a curated selection of task-based chatbots from GitHub, developed using the most popular commercial and open-source platforms.

</details>


### [10] [Source Code Hotspots: A Diagnostic Method for Quality Issues](https://arxiv.org/abs/2602.13170)
*Saleha Muzammil,Mughees Ur Rehman,Zoe Kotti,Diomidis Spinellis*

Main category: cs.SE

TL;DR: 研究发现代码热点主要由自动化账户产生（74%），识别出15种热点模式，其中前三种是版本固定更新（26%）、长行变更（17%）和格式乒乓（9%），并提供了具体的重构指南和CI检查来改善软件质量。


<details>
  <summary>Details</summary>
Motivation: 软件源代码中常存在"热点"区域——这些代码片段比其他部分变更更频繁，集中了大量维护活动。研究旨在理解这些热点为何出现，并帮助开发者减少热点，提高软件质量。

Method: 分析了91个活跃开发的GitHub仓库的完整版本历史，识别出15种重复出现的行级热点模式，并将每种模式映射到具体的重构指南和持续集成检查。

Result: 发现自动化账户产生了74%的热点编辑，表明机器人活动是变更历史中主要但基本可避免的噪音源。前三种热点模式是：版本固定更新（26%）、长行变更（17%）和格式乒乓（9%）。

Conclusion: 通过将热点模式映射到具体的重构指南和CI检查，该分类法为开发者提供了可操作的步骤来抑制热点，系统性地提高软件在可配置性、稳定性和可变更性方面的质量。

Abstract: Software source code often harbours "hotspots": small portions of the code that change far more often than the rest of the project and thus concentrate maintenance activity. We mine the complete version histories of 91 evolving, actively developed GitHub repositories and identify 15 recurring line-level hotspot patterns that explain why these hotspots emerge. The three most prevalent patterns are Pinned Version Bump (26%), revealing brittle release practices; Long Line Change (17%), signalling deficient layout; and Formatting Ping-Pong (9%), indicating missing or inconsistent style automation. Surprisingly, automated accounts generate 74% of all hotspot edits, suggesting that bot activity is a dominant but largely avoidable source of noise in change histories. By mapping each pattern to concrete refactoring guidelines and continuous integration checks, our taxonomy equips practitioners with actionable steps to curb hotspots and systematically improve software quality in terms of configurability, stability, and changeability.

</details>


<div id='cs.DB'></div>

# cs.DB [[Back]](#toc)

### [11] [Monte Carlo Tree Search with Reasoning Path Refinement for Small Language Models in Conversational Text-to-NoSQL](https://arxiv.org/abs/2602.12574)
*Xubang Xiong,Raymond Chi-Wing Wong,Yuanfeng Song*

Main category: cs.DB

TL;DR: 提出对话式文本到NoSQL任务，通过Stage-MCTS框架增强小语言模型的NoSQL推理能力，在构建的CoNoSQL数据集上取得优于大模型的性能。


<details>
  <summary>Details</summary>
Motivation: NoSQL数据库查询需要专业技术知识，现有文本到NoSQL研究主要关注单轮交互，忽略了现实查询的对话性质，需要解决对话式查询生成问题。

Method: 提出Stage-MCTS框架，将查询生成建模为搜索问题，使用蒙特卡洛树搜索（MCTS）结合基于规则的奖励生成逐步推理数据，然后采用渐进式监督微调和自训练策略。

Result: 在构建的CoNoSQL数据集（包含2000+对话和150个数据库）上实验，方法优于最先进的大型推理模型，执行值匹配（EVM）准确率提升高达7.93%。

Conclusion: 提出的对话式文本到NoSQL任务和Stage-MCTS框架有效解决了多轮对话中的NoSQL查询生成问题，显著提升了小语言模型在该任务上的性能。

Abstract: NoSQL databases have been widely adopted in big data analytics, geospatial applications, and healthcare services, due to their flexibility and scalability. However, querying NoSQL databases requires specialized technical expertise, creating a high barrier for users. While recent studies have explored text-to-NoSQL problem, they primarily focus on single-turn interactions, ignoring the conversational nature of real-world queries. To bridge this gap, we introduce the Conversational Text-to-NoSQL task, which generates NoSQL queries given a natural language question, a NoSQL database, and the dialogue history. To address this task, we propose Stage-MCTS, a framework that endows small language models (SLMs) with NoSQL-specific reasoning capabilities by formulating query generation as a search problem. The framework employs Monte Carlo Tree Search (MCTS) guided by a rule-based reward to produce stepwise reasoning data, followed by progressive supervised fine-tuning (SFT) and self-training strategies. We further construct CoNoSQL, a cross-domain dataset with over 2,000 dialogues and 150 databases, to support evaluation. Experiments demonstrate that our approach outperforms state-of-the-art large reasoning models, improving execution value match (EVM) accuracy by up to 7.93%.

</details>


### [12] [Implicit Representation of Structural Constraints in ER-to-Relational Transformation: An Analysis of Cardinality Preservation](https://arxiv.org/abs/2602.12856)
*Dhammika Pieris*

Main category: cs.DB

TL;DR: ER模型到关系数据库的转换中，结构约束（最小/最大参与度）在逻辑模式中无法被明确表示


<details>
  <summary>Details</summary>
Motivation: 研究概念模式中定义的结构约束在转换到逻辑模式后是否能够被准确表示，特别是在经典的ER到关系数据库转换框架下

Method: 使用包含二元关系类型的ER模型，在经典转换框架下（仅通过主键和外键约束定义逻辑模式），分析广义ER模型到关系数据库模式的转换结果

Result: 对于一对一和一对多关系，关系数据库模式无法明确表示最小参与约束，也无法编码精确的最大参与度（除有限情况外）；对于多对多关系，模式仅能表明最大基数超过1，无法保留精确值

Conclusion: 标准ER到关系转换存在表示限制，这对模式设计和约束执行具有重要意义，需要额外的机制来确保结构约束的完整性

Abstract: This study examines the extent to which structural constraints specified in conceptual schemas are represented after transformation to logical schemas. Focusing on the conceptual-to-logical mapping, an Entity-Relationship (ER) model containing binary relationship types is transformed into a Relational Database Schema (RDS). The analysis is conducted under the classical transformation framework in which the logical schema is defined solely by primary key (PK) and foreign key (FK) constraints. Using generalised ER models with variable structural constraint values, the resulting RDS structures are evaluated to determine whether minimum and maximum participation constraints are represented unambiguously. The findings show that, for one-to-one and one-to-many relationships, RDSs do not unambiguously capture minimum participation constraints and do not encode exact maximum participation beyond limited cases. For many-to-many relationships, the schema indicates only that maximum cardinalities exceed one, without preserving exact values. These results clarify the representational limits of standard ER-to-relational transformations and have implications for schema design and constraint enforcement.

</details>


<div id='cs.DC'></div>

# cs.DC [[Back]](#toc)

### [13] [Distance-based certification for leader election in meshed graphs and local recognition of their subclasses](https://arxiv.org/abs/2602.12894)
*Jérémie Chalopin,Victor Chepoi,Maria Kokkou*

Main category: cs.DC

TL;DR: 本文提出了针对匿名网格图的2-local证明标签方案，使用{0,1,2}标签实现领导者选举，并为网格图的子类提供3-local识别方案。


<details>
  <summary>Details</summary>
Motivation: 研究网格图及其重要子类（如中位数图、桥接图、弦图等）的本地验证问题，这些图在度量图论、几何群论和离散数学中被广泛研究。目标是设计高效的本地证明标签方案来解决领导者选举和图类识别问题。

Method: 1. 在网格图中，通过本地验证每个顶点v到根节点s的距离d(s,v)来建立基础
2. 对于子类识别，使用距离验证确保图的三角形-正方形复形是单连通的，然后依赖现有的局部到全局特征化方法
3. 对于领导者选举，本地检查每个顶点v是否被标记为d(s,v) mod 3，其中s被指定为领导者

Result: 1. 为匿名网格图的领导者选举提供了2-local证明标签方案，仅使用{0,1,2}三个标签
2. 为网格图的多个重要子类提供了3-local识别方案，标签大小为O(log D)，其中D是图直径
3. 证明了在网格图中可以本地验证顶点到根节点的距离

Conclusion: 本文成功设计了针对网格图及其子类的高效本地证明标签方案，特别是实现了常数大小标签的领导者选举方案。这些结果扩展了本地验证技术在重要图类上的应用，为度量图论和分布式计算提供了新的工具。

Abstract: In this paper, we present a 2-local proof labeling scheme with labels in $\{ 0,1,2\}$ for leader election in anonymous meshed graphs. Meshed graphs form a general class of graphs defined by a distance condition. They comprise several important classes of graphs, which have long been the subject of intensive studies in metric graph theory, geometric group theory, and discrete mathematics: median graphs, bridged graphs, chordal graphs, Helly graphs, dual polar graphs, modular, weakly modular graphs, and basis graphs of matroids. We also provide 3-local proof labeling schemes to recognize these subclasses of meshed graphs using labels of size $O(\log D)$ (where $D$ is the diameter of the graph).
  To establish these results, we show that in meshed graphs, we can verify locally that every vertex $v$ is labeled by its distance $d(s,v)$ to an arbitrary root $s$. To design proof labeling schemes to recognize the subclasses of meshed graphs mentioned above, we use this distance verification to ensure that the triangle-square complex of the graph is simply connected and we then rely on existing local-to-global characterizations for the different classes we consider.
  To get a proof-labeling scheme for leader election with labels of constant size, we then show that we can check locally if every $v$ is labeled by $d(s,v) \pmod{3}$ for some root $s$ that we designate as the leader.

</details>


### [14] [Classification of Local Optimization Problems in Directed Cycles](https://arxiv.org/abs/2602.13046)
*Thomas Boudier,Fabian Kuhn,Augusto Modanese,Ronja Stimpert,Jukka Suomela*

Main category: cs.DC

TL;DR: 本文对定向环中的局部优化问题的分布式计算复杂度进行了完整分类，确定了四种可能的复杂度类别，并提供了自动确定复杂度和合成最优分布式算法的元算法。


<details>
  <summary>Details</summary>
Motivation: 局部优化问题（如最大独立集、最小顶点覆盖等）在分布式计算中广泛研究，但之前只对局部搜索问题有类似的复杂度分类结果。本文旨在将这种分类扩展到更一般的局部优化问题家族。

Method: 对定向环中的局部优化问题进行系统分析，考虑确定性LOCAL和随机化LOCAL模型，研究不同近似比下的计算复杂度。开发了高效的集中式元算法来自动确定任何给定问题和近似比的复杂度类别。

Result: 证明了局部优化问题在定向环中只有四种可能的复杂度类别：O(1)轮确定性/O(1)轮随机化；Θ(log* n)轮确定性/O(1)轮随机化；Θ(log* n)轮确定性/Θ(log* n)轮随机化；Θ(n)轮确定性/Θ(n)轮随机化。并提供了自动确定复杂度和合成最优算法的元算法。

Conclusion: 本文首次对局部优化问题在定向环中的分布式计算复杂度进行了完整分类，将之前仅适用于局部搜索问题的结果推广到更广泛的优化问题家族，为理解分布式优化问题的计算复杂性提供了系统框架。

Abstract: We present a complete classification of the distributed computational complexity of local optimization problems in directed cycles for both the deterministic and the randomized LOCAL model. We show that for any local optimization problem $Π$ (that can be of the form min-sum, max-sum, min-max, or max-min, for any local cost or utility function over some finite alphabet), and for any \emph{constant} approximation ratio $α$, the task of finding an $α$-approximation of $Π$ in directed cycles has one of the following complexities:
  1. $O(1)$ rounds in deterministic LOCAL, $O(1)$ rounds in randomized LOCAL,
  2. $Θ(\log^* n)$ rounds in deterministic LOCAL, $O(1)$ rounds in randomized LOCAL,
  3. $Θ(\log^* n)$ rounds in deterministic LOCAL, $Θ(\log^* n)$ rounds in randomized LOCAL,
  4. $Θ(n)$ rounds in deterministic LOCAL, $Θ(n)$ rounds in randomized LOCAL.
  Moreover, for any given $Π$ and $α$, we can determine the complexity class automatically, with an efficient (centralized, sequential) meta-algorithm, and we can also efficiently synthesize an asymptotically optimal distributed algorithm.
  Before this work, similar results were only known for local search problems (e.g., locally checkable labeling problems). The family of local optimization problems is a strict generalization of local search problems, and it contains numerous commonly studied distributed tasks, such as the problems of finding approximations of the maximum independent set, minimum vertex cover, minimum dominating set, and minimum vertex coloring.

</details>


### [15] [Bloom Filter Look-Up Tables for Private and Secure Distributed Databases in Web3 (Revised Version)](https://arxiv.org/abs/2602.13167)
*Shlomi Dolev,Ehud Gudes,Daniel Shlomo*

Main category: cs.DC

TL;DR: 提出基于BFLUT算法的去中心化密钥管理方案，结合OrbitDB、IPFS和IPNS技术，实现安全、隐私且可扩展的Web3密钥管理


<details>
  <summary>Details</summary>
Motivation: Web3生态系统中的去中心化系统面临数据安全、隐私和可扩展性挑战，特别是密钥管理在分布式环境中存在风险，节点可能被攻击者控制

Method: 使用BFLUT算法对密钥进行编码和分布式存储，避免明文存储；结合OrbitDB、IPFS和IPNS构建去中心化数据库方案，支持一致性、可扩展性和并发更新

Result: 系统能够安全管理密钥，防止未授权访问，确保隐私保护，同时保持高性能和可靠性，为需要去中心化安全的Web3应用提供基础解决方案

Conclusion: 该去中心化密钥管理方案通过创新的BFLUT算法和分布式技术组合，有效解决了Web3环境中的密钥安全挑战，为去中心化系统提供了安全、隐私且可扩展的密钥管理基础架构

Abstract: The rapid growth of decentralized systems in theWeb3 ecosystem has introduced numerous challenges, particularly in ensuring data security, privacy, and scalability [3, 8]. These systems rely heavily on distributed architectures, requiring robust mechanisms to manage data and interactions among participants securely. One critical aspect of decentralized systems is key management, which is essential for encrypting files, securing database segments, and enabling private transactions. However, securely managing cryptographic keys in a distributed environment poses significant risks, especially when nodes in the network can be compromised [9]. This research proposes a decentralized database scheme specifically designed for secure and private key management. Our approach ensures that cryptographic keys are not stored explicitly at any location, preventing their discovery even if an attacker gains control of multiple nodes. Instead of traditional storage, keys are encoded and distributed using the BFLUT (Bloom Filter for Private Look-Up Tables) algorithm [7], which enables secure retrieval without direct exposure. The system leverages OrbitDB [4], IPFS [1], and IPNS [10] for decentralized data management, providing robust support for consistency, scalability, and simultaneous updates. By combining these technologies, our scheme enhances both security and privacy while maintaining high performance and reliability. Our findings demonstrate the system's capability to securely manage keys, prevent unauthorized access, and ensure privacy, making it a foundational solution for Web3 applications requiring decentralized security.

</details>
