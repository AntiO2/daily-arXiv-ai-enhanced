{"id": "2509.20563", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2509.20563", "abs": "https://arxiv.org/abs/2509.20563", "authors": ["Skyler Ruiter", "Jiannan Tian", "Fengguang Song"], "title": "FZModules: A Heterogeneous Computing Framework for Customizable Scientific Data Compression Pipelines", "comment": null, "summary": "Modern scientific simulations and instruments generate data volumes that\noverwhelm memory and storage, throttling scalability. Lossy compression\nmitigates this by trading controlled error for reduced footprint and throughput\ngains, yet optimal pipelines are highly data and objective specific, demanding\ncompression expertise. GPU compressors supply raw throughput but often\nhard-code fused kernels that hinder rapid experimentation, and underperform in\nrate-distortion. We present FZModules, a heterogeneous framework for assembling\nerror-bounded custom compression pipelines from high-performance modules\nthrough a concise extensible interface. We further utilize an asynchronous\ntask-backed execution library that infers data dependencies, manages memory\nmovement, and exposes branch and stage level concurrency for powerful\nasynchronous compression pipelines. Evaluating three pipelines built with\nFZModules on four representative scientific datasets, we show they can compare\nend-to-end speedup of fused-kernel GPU compressors while achieving similar\nrate-distortion to higher fidelity CPU or hybrid compressors, enabling rapid,\ndomain-tailored design."}
{"id": "2509.20603", "categories": ["cs.DC", "cs.AI", "cs.AR", "cs.ET", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.20603", "abs": "https://arxiv.org/abs/2509.20603", "authors": ["Angel M. Beltre", "Jeff Ogden", "Kevin Pedretti"], "title": "Experience Deploying Containerized GenAI Services at an HPC Center", "comment": "10 pages, 12 figures", "summary": "Generative Artificial Intelligence (GenAI) applications are built from\nspecialized components -- inference servers, object storage, vector and graph\ndatabases, and user interfaces -- interconnected via web-based APIs. While\nthese components are often containerized and deployed in cloud environments,\nsuch capabilities are still emerging at High-Performance Computing (HPC)\ncenters. In this paper, we share our experience deploying GenAI workloads\nwithin an established HPC center, discussing the integration of HPC and cloud\ncomputing environments. We describe our converged computing architecture that\nintegrates HPC and Kubernetes platforms running containerized GenAI workloads,\nhelping with reproducibility. A case study illustrates the deployment of the\nLlama Large Language Model (LLM) using a containerized inference server (vLLM)\nacross both Kubernetes and HPC platforms using multiple container runtimes. Our\nexperience highlights practical considerations and opportunities for the HPC\ncontainer community, guiding future research and tool development."}
{"id": "2509.20776", "categories": ["cs.DC", "cs.MS", "G.4"], "pdf": "https://arxiv.org/pdf/2509.20776", "abs": "https://arxiv.org/abs/2509.20776", "authors": ["Elaheh Hassani", "Md Taufique Hussain", "Ariful Azad"], "title": "Distributed-memory Algorithms for Sparse Matrix Permutation, Extraction, and Assignment", "comment": "32 pages", "summary": "We present scalable distributed-memory algorithms for sparse matrix\npermutation, extraction, and assignment. Our methods follow an\nIdentify-Exchange-Build (IEB) strategy where each process identifies the local\nnonzeros to be sent, exchanges the required data, and then builds its local\nsubmatrix from the received elements. This approach reduces communication\ncompared to SpGEMM-based methods in distributed memory. By employing\nsynchronization-free multithreaded algorithms, we further accelerate local\ncomputations, achieving substantially better performance than existing\nlibraries such as CombBLAS and PETSc. We design efficient software for these\noperations and evaluate their performance on two university clusters and the\nPerlmutter supercomputer. Our experiments span a variety of application\nscenarios, including matrix permutation for load balancing, matrix reordering,\nsubgraph extraction, and streaming graph applications. In all cases, we compare\nour algorithms against CombBLAS, the most comprehensive distributed library for\nthese operations, and, in some scenarios, against PETSc. Overall, this work\nprovides a comprehensive study of algorithms, software implementations,\nexperimental evaluations, and applications for sparse matrix permutation,\nextraction, and assignment."}
{"id": "2509.20819", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2509.20819", "abs": "https://arxiv.org/abs/2509.20819", "authors": ["Andre Merzky", "Mikhail Titov", "Matteo Turilli", "Shantenu Jha"], "title": "Integrating and Characterizing HPC Task Runtime Systems for hybrid AI-HPC workloads", "comment": "12 pages, 1 table, 8 figures", "summary": "Scientific workflows increasingly involve both HPC and machine-learning\ntasks, combining MPI-based simulations, training, and inference in a single\nexecution. Launchers such as Slurm's srun constrain concurrency and throughput,\nmaking them unsuitable for dynamic and heterogeneous workloads. We present a\nperformance study of RADICAL-Pilot (RP) integrated with Flux and Dragon, two\ncomplementary runtime systems that enable hierarchical resource management and\nhigh-throughput function execution. Using synthetic and production-scale\nworkloads on Frontier, we characterize the task execution properties of RP\nacross runtime configurations. RP+Flux sustains up to 930 tasks/s, and\nRP+Flux+Dragon exceeds 1,500 tasks/s with over 99.6% utilization. In contrast,\nsrun peaks at 152 tasks/s and degrades with scale, with utilization below 50%.\nFor IMPECCABLE.v2 drug discovery campaign, RP+Flux reduces makespan by 30-60%\nrelative to srun/Slurm and increases throughput more than four times on up to\n1,024. These results demonstrate hybrid runtime integration in RP as a scalable\napproach for hybrid AI-HPC workloads."}
{"id": "2509.21009", "categories": ["cs.DC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.21009", "abs": "https://arxiv.org/abs/2509.21009", "authors": ["Wei Gao", "Yuheng Zhao", "Dakai An", "Tianyuan Wu", "Lunxi Cao", "Shaopan Xiong", "Ju Huang", "Weixun Wang", "Siran Yang", "Wenbo Su", "Jiamang Wang", "Lin Qu", "Bo Zheng", "Wei Wang"], "title": "RollPacker: Mitigating Long-Tail Rollouts for Fast, Synchronous RL Post-Training", "comment": "16pages,14 figures", "summary": "Reinforcement Learning (RL) is a pivotal post-training technique for\nenhancing the reasoning capabilities of Large Language Models (LLMs). However,\nsynchronous RL post-training often suffers from significant GPU\nunderutilization, referred to as bubbles, caused by imbalanced response lengths\nwithin rollout steps. Many RL systems attempt to alleviate this problem by\nrelaxing synchronization, but this can compromise training accuracy. In this\npaper, we introduce tail batching, a novel rollout scheduling strategy for\nsynchronous RL that systematically consolidates prompts leading to long-tail\nresponses into a small subset of rollout steps (long rounds), while ensuring\nthat the majority of steps (short rounds) involve only balanced, short\nrollouts. By excluding long responses from short rounds and rescheduling them\ninto a few designated long rounds, tail batching effectively reduces GPU idle\ntime during rollouts and significantly accelerates RL training without\nsacrificing accuracy. We present RollPacker, a system that fully harnesses the\nbenefits of tail batching through holistic optimizations across all three RL\nstages: elastic parallelism adaptation for rollout, dynamic resource allocation\nand scheduling for reward, and stream-based training. Empirical results show\nthat RollPacker achieves a 2.03x-2.56x end-to-end training time reduction\ncompared to veRL and up to 2.24x speedup compared to RLHFuse for the Qwen2.5\nfamily of LLMs on up to 128 H800 GPUs."}
{"id": "2509.21037", "categories": ["cs.DC", "cs.MS", "D.1.3; G.1.3; G.4"], "pdf": "https://arxiv.org/pdf/2509.21037", "abs": "https://arxiv.org/abs/2509.21037", "authors": ["Jakub Homola", "Ondřej Meca", "Lubomír Říha", "Tomáš Brzobohatý"], "title": "Utilizing Sparsity in the GPU-accelerated Assembly of Schur Complement Matrices in Domain Decomposition Methods", "comment": "12 pages (originally 10 pages without references), 10 figures,\n  submitted to SC25 conference", "summary": "Schur complement matrices emerge in many domain decomposition methods that\ncan solve complex engineering problems using supercomputers. Today, as most of\nthe high-performance clusters' performance lies in GPUs, these methods should\nalso be accelerated.\n  Typically, the offloaded components are the explicitly assembled dense Schur\ncomplement matrices used later in the iterative solver for multiplication with\na vector. As the explicit assembly is expensive, it represents a significant\noverhead associated with this approach to acceleration. It has already been\nshown that the overhead can be minimized by assembling the Schur complements\ndirectly on the GPU.\n  This paper shows that the GPU assembly can be further improved by wisely\nutilizing the sparsity of the input matrices. In the context of FETI methods,\nwe achieved a speedup of 5.1 in the GPU section of the code and 3.3 for the\nwhole assembly, making the acceleration beneficial from as few as 10\niterations."}
{"id": "2509.21039", "categories": ["cs.DC", "cs.CE", "cs.ET", "cs.PL"], "pdf": "https://arxiv.org/pdf/2509.21039", "abs": "https://arxiv.org/abs/2509.21039", "authors": ["William F. Godoy", "Tatiana Melnichenko", "Pedro Valero-Lara", "Wael Elwasif", "Philip Fackler", "Rafael Ferreira Da Silva", "Keita Teranishi", "Jeffrey S. Vetter"], "title": "Mojo: MLIR-Based Performance-Portable HPC Science Kernels on GPUs for the Python Ecosystem", "comment": "Accepted at the IEEE/ACM SC25 Conference WACCPD Workshop. The\n  International Conference for High Performance Computing, Networking, Storage,\n  and Analysis, St. Louis, MO, Nov 16-21, 2025. 15 pages, 7 figures. WFG and TM\n  contributed equally", "summary": "We explore the performance and portability of the novel Mojo language for\nscientific computing workloads on GPUs. As the first language based on the\nLLVM's Multi-Level Intermediate Representation (MLIR) compiler infrastructure,\nMojo aims to close performance and productivity gaps by combining Python's\ninteroperability and CUDA-like syntax for compile-time portable GPU\nprogramming. We target four scientific workloads: a seven-point stencil\n(memory-bound), BabelStream (memory-bound), miniBUDE (compute-bound), and\nHartree-Fock (compute-bound with atomic operations); and compare their\nperformance against vendor baselines on NVIDIA H100 and AMD MI300A GPUs. We\nshow that Mojo's performance is competitive with CUDA and HIP for memory-bound\nkernels, whereas gaps exist on AMD GPUs for atomic operations and for fast-math\ncompute-bound kernels on both AMD and NVIDIA GPUs. Although the learning curve\nand programming requirements are still fairly low-level, Mojo can close\nsignificant gaps in the fragmented Python ecosystem in the convergence of\nscientific computing and AI."}
{"id": "2509.21137", "categories": ["cs.DC", "cs.AR", "cs.ET"], "pdf": "https://arxiv.org/pdf/2509.21137", "abs": "https://arxiv.org/abs/2509.21137", "authors": ["Huynh Q. N. Vo", "Md Tawsif Rahman Chowdhury", "Paritosh Ramanan", "Gozde Tutuncuoglu", "Junchi Yang", "Feng Qiu", "Murat Yildirim"], "title": "From GPUs to RRAMs: Distributed In-Memory Primal-Dual Hybrid Gradient Method for Solving Large-Scale Linear Optimization Problem", "comment": "Main Article (12 Pages, 3 Figures), Appendix (4 Pages)", "summary": "The exponential growth of computational workloads is surpassing the\ncapabilities of conventional architectures, which are constrained by\nfundamental limits. In-memory computing (IMC) with RRAM provides a promising\nalternative by providing analog computations with significant gains in latency\nand energy use. However, existing algorithms developed for conventional\narchitectures do not translate to IMC, particularly for constrained\noptimization problems where frequent matrix reprogramming remains\ncost-prohibitive for IMC applications. Here we present a distributed in-memory\nprimal-dual hybrid gradient (PDHG) method, specifically co-designed for arrays\nof RRAM devices. Our approach minimizes costly write cycles, incorporates\nrobustness against device non-idealities, and leverages a symmetric\nblock-matrix formulation to unify operations across distributed crossbars. We\nintegrate a physics-based simulation framework called MELISO+ to evaluate\nperformance under realistic device conditions. Benchmarking against\nGPU-accelerated solvers on large-scale linear programs demonstrates that our\nRRAM-based solver achieves comparable accuracy with up to three orders of\nmagnitude reductions in energy consumption and latency. These results\ndemonstrate the first PDHG-based LP solver implemented on RRAMs, showcasing the\ntransformative potential of algorithm-hardware co-design for solving\nlarge-scale optimization through distributed in-memory computing."}
{"id": "2509.21275", "categories": ["cs.DC", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.21275", "abs": "https://arxiv.org/abs/2509.21275", "authors": ["Shiju Wang", "Yujie Wang", "Ao Sun", "Fangcheng Fu", "Zijian Zhu", "Bin Cui", "Xu Han", "Kaisheng Ma"], "title": "Data-Centric Elastic Pipeline Parallelism for Efficient Long-Context LLM Training", "comment": null, "summary": "Long context training is crucial for LLM's context extension. Existing\nschemes, such as sequence parallelism, incur substantial communication\noverhead. Pipeline parallelism (PP) reduces this cost, but its effectiveness\nhinges on partitioning granularity. Batch-level PP dividing input samples\nexhibits high memory consumption in long-context scenario, whereas token-level\nPP splitting sequences into slices alleviates memory overhead but may incur\nhardware under-utilization. This trade-off motivates adaptively selecting PP\ngranularity to match resource and workload characteristics. Moreover, sequence\nlength distribution of the real-world dataset exhibits skewness, posing a\nchallenge on PP's workload balance and efficient scheduling. Current static PP\nscheduling methods overlook the variance of sequence length, leading to\nsuboptimal performance. In this paper, we propose Elastic Pipeline Parallelism\n(EPP) that orchestrates token-level PP and batch-level PP to adapt to resource\nand workload heterogeneity. We build InfiniPipe, a distributed training system\nthat unleashes the potential of EPP via (1) a resource-aware and\nworkload-balanced sequence processor that splits long sequences and packs short\nones; and (2) a co-optimization methodology that jointly optimizes pipeline\nschedule and gradient checkpointing via a mechanism named stage-aware\nchunk-level adaptive checkpointing. Comprehensive experiments demonstrate that\nInfiniPipe achieves a 1.69x speedup over state-of-the-art systems."}
