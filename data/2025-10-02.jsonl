{"id": "2510.00039", "categories": ["cs.DB", "cs.AI", "cs.IR"], "pdf": "https://arxiv.org/pdf/2510.00039", "abs": "https://arxiv.org/abs/2510.00039", "authors": ["Hossein Sholehrasa", "Amirhossein Ghanaatian", "Doina Caragea", "Lisa A. Tell", "Jim E. Riviere", "Majid Jaberi-Douraki"], "title": "AutoPK: Leveraging LLMs and a Hybrid Similarity Metric for Advanced Retrieval of Pharmacokinetic Data from Complex Tables and Documents", "comment": "Accepted at the 2025 IEEE 37th ICTAI", "summary": "Pharmacokinetics (PK) plays a critical role in drug development and\nregulatory decision-making for human and veterinary medicine, directly\naffecting public health through drug safety and efficacy assessments. However,\nPK data are often embedded in complex, heterogeneous tables with variable\nstructures and inconsistent terminologies, posing significant challenges for\nautomated PK data retrieval and standardization. AutoPK, a novel two-stage\nframework for accurate and scalable extraction of PK data from complex\nscientific tables. In the first stage, AutoPK identifies and extracts PK\nparameter variants using large language models (LLMs), a hybrid similarity\nmetric, and LLM-based validation. The second stage filters relevant rows,\nconverts the table into a key-value text format, and uses an LLM to reconstruct\na standardized table. Evaluated on a real-world dataset of 605 PK tables,\nincluding captions and footnotes, AutoPK shows significant improvements in\nprecision and recall over direct LLM baselines. For instance, AutoPK with LLaMA\n3.1-70B achieved an F1-score of 0.92 on half-life and 0.91 on clearance\nparameters, outperforming direct use of LLaMA 3.1-70B by margins of 0.10 and\n0.21, respectively. Smaller models such as Gemma 3-27B and Phi 3-12B with\nAutoPK achieved 2-7 fold F1 gains over their direct use, with Gemma's\nhallucination rates reduced from 60-95% down to 8-14%. Notably, AutoPK enabled\nopen-source models like Gemma 3-27B to outperform commercial systems such as\nGPT-4o Mini on several PK parameters. AutoPK enables scalable and\nhigh-confidence PK data extraction, making it well-suited for critical\napplications in veterinary pharmacology, drug safety monitoring, and public\nhealth decision-making, while addressing heterogeneous table structures and\nterminology and demonstrating generalizability across key PK parameters. Code\nand data: https://github.com/hosseinsholehrasa/AutoPK"}
{"id": "2510.00089", "categories": ["cs.DB", "cs.CY"], "pdf": "https://arxiv.org/pdf/2510.00089", "abs": "https://arxiv.org/abs/2510.00089", "authors": ["Eduardo Vyhmeister", "Bastien Pietropoli", "Andrea Visentin"], "title": "Data Quality Taxonomy for Data Monetization", "comment": null, "summary": "This chapter presents a comprehensive taxonomy for assessing data quality in\nthe context of data monetisation, developed through a systematic literature\nreview. Organising over one hundred metrics and Key Performance Indicators\n(KPIs) into four subclusters (Fundamental, Contextual, Resolution, and\nSpecialised) within the Balanced Scorecard (BSC) framework, the taxonomy\nintegrates both universal and domain-specific quality dimensions. By\npositioning data quality as a strategic connector across the BSC's Financial,\nCustomer, Internal Processes, and Learning & Growth perspectives, it\ndemonstrates how quality metrics underpin valuation accuracy, customer trust,\noperational efficiency, and innovation capacity. The framework's interconnected\n\"metrics layer\" ensures that improvements in one dimension cascade into others,\nmaximising strategic impact. This holistic approach bridges the gap between\ngranular technical assessment and high-level decision-making, offering\npractitioners, data stewards, and strategists a scalable, evidence-based\nreference for aligning data quality management with sustainable value creation."}
{"id": "2510.00549", "categories": ["cs.DB", "cs.AI", "I.2.7; H.2.8"], "pdf": "https://arxiv.org/pdf/2510.00549", "abs": "https://arxiv.org/abs/2510.00549", "authors": ["Kwanhyung Lee", "Sungsoo Hong", "Joonhyung Park", "Jeonghyeop Lim", "Juhwan Choi", "Donghwee Yoon", "Eunho Yang"], "title": "EMR-AGENT: Automating Cohort and Feature Extraction from EMR Databases", "comment": "currently under submission to ICLR 2026", "summary": "Machine learning models for clinical prediction rely on structured data\nextracted from Electronic Medical Records (EMRs), yet this process remains\ndominated by hardcoded, database-specific pipelines for cohort definition,\nfeature selection, and code mapping. These manual efforts limit scalability,\nreproducibility, and cross-institutional generalization. To address this, we\nintroduce EMR-AGENT (Automated Generalized Extraction and Navigation Tool), an\nagent-based framework that replaces manual rule writing with dynamic, language\nmodel-driven interaction to extract and standardize structured clinical data.\nOur framework automates cohort selection, feature extraction, and code mapping\nthrough interactive querying of databases. Our modular agents iteratively\nobserve query results and reason over schema and documentation, using SQL not\njust for data retrieval but also as a tool for database observation and\ndecision making. This eliminates the need for hand-crafted, schema-specific\nlogic. To enable rigorous evaluation, we develop a benchmarking codebase for\nthree EMR databases (MIMIC-III, eICU, SICdb), including both seen and unseen\nschema settings. Our results demonstrate strong performance and generalization\nacross these databases, highlighting the feasibility of automating a process\npreviously thought to require expert-driven design. The code will be released\npublicly at https://github.com/AITRICS/EMR-AGENT/tree/main. For a\ndemonstration, please visit our anonymous demo page:\nhttps://anonymoususer-max600.github.io/EMR_AGENT/"}
{"id": "2510.00002", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.00002", "abs": "https://arxiv.org/abs/2510.00002", "authors": ["Dong Liu"], "title": "PBFD and PDFD: Formally Defined and Verified Methodologies and Empirical Evaluation for Scalable Full-Stack Software Engineering", "comment": "184 pages; 35 figures; A DOI-linked version of this paper and all\n  supplementary materials are available on Zenodo at\n  https://zenodo.org/records/16883985", "summary": "This paper introduces Primary Breadth-First Development (PBFD) and Primary\nDepth-First Development (PDFD), two formally defined and verified methodologies\nfor scalable, industrial-grade full-stack software engineering. These\napproaches bridge a longstanding gap between formal methods and real-world\ndevelopment practice by enforcing structural correctness through\ngraph-theoretic modeling. Unlike prior graph-based approaches, PBFD and PDFD\noperate over layered directed graphs and are formalized using unified state\nmachines and Communicating Sequential Processes (CSP) to ensure critical\nproperties, including bounded-refinement termination and structural\ncompleteness. To coordinate hierarchical data at scale, we propose Three-Level\nEncapsulation (TLE) - a novel, bitmask-based encoding scheme that delivers\nprovably constant-time updates. TLE's formal guarantees underpin PBFD's\nindustrial-scale performance and scalability. PBFD was empirically validated\nthrough an eight-year enterprise deployment, demonstrating over 20x faster\ndevelopment than Salesforce OmniScript and 7-8x faster query performance\ncompared to conventional relational models. Additionally, both methodologies\nare supported by open-source MVPs, with PDFD's implementation conclusively\ndemonstrating its correctness-first design principles. Together, PBFD and PDFD\nestablish a reproducible, transparent framework that integrates formal\nverification into practical software development. All formal specifications,\nMVPs, and datasets are publicly available to foster academic research and\nindustrial-grade adoption."}
{"id": "2510.00183", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2510.00183", "abs": "https://arxiv.org/abs/2510.00183", "authors": ["Ween Yang", "Jason Liu", "Suli Wang", "Xinyuan Song", "Lynn Ai", "Eric Yang", "Tianyu Shi"], "title": "Lattica: A Decentralized Cross-NAT Communication Framework for Scalable AI Inference and Training", "comment": null, "summary": "The rapid expansion of distributed Artificial Intelligence (AI) workloads\nbeyond centralized data centers creates a demand for new communication\nsubstrates. These substrates must operate reliably in heterogeneous and\npermissionless environments, where Network Address Translators (NATs) and\nfirewalls impose significant constraints. Existing solutions, however, are\neither designed for controlled data center deployments or implemented as\nmonolithic systems that tightly couple machine learning logic with networking\ncode. To address these limitations, we present Lattica, a decentralized\ncross-NAT communication framework designed to support distributed AI systems.\nLattica integrates three core components. First, it employs a robust suite of\nNAT traversal mechanisms to establish a globally addressable peer-to-peer mesh.\nSecond, it provides a decentralized data store based on Conflict-free\nReplicated Data Types (CRDTs), ensuring verifiable and eventually consistent\nstate replication. Third, it incorporates a content discovery layer that\nleverages distributed hash tables (DHTs) together with an optimized RPC\nprotocol for efficient model synchronization. By integrating these components,\nLattica delivers a complete protocol stack for sovereign, resilient, and\nscalable AI systems that operate independently of centralized intermediaries.\nIt is directly applicable to edge intelligence, collaborative reinforcement\nlearning, and other large-scale distributed machine learning scenarios."}
{"id": "2510.00003", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.00003", "abs": "https://arxiv.org/abs/2510.00003", "authors": ["Malte Hansen", "Jens Bamberg", "Noe Baumann", "Wilhelm Hasselbring"], "title": "Semantic Zoom and Mini-Maps for Software Cities", "comment": "Copyright 2025 IEEE. Personal use of this material is permitted.\n  Permission from IEEE must be obtained for all other uses, in any current or\n  future media, including reprinting/republishing this material for advertising\n  or promotional purposes, creating new collective works, for resale or\n  redistribution to servers or lists, or reuse of any copyrighted component of\n  this work in other works", "summary": "Software visualization tools can facilitate program comprehension by\nproviding visual metaphors, or abstractions that reduce the amount of textual\ndata that needs to be processed mentally. One way they do this is by enabling\ndevelopers to build an internal representation of the visualized software and\nits architecture. However, as the amount of displayed data in the visualization\nincreases, the visualization itself can become more difficult to comprehend.\nThe ability to display small and large amounts of data in visualizations is\ncalled visual scalability.\n  In this paper, we present two approaches to address the challenge of visual\nscalability in 3D software cities. First, we present an approach to semantic\nzoom, in which the graphical representation of the software landscape changes\nbased on the virtual camera's distance from visual objects. Second, we augment\nthe visualization with a miniature two-dimensional top-view projection called\nmini-map. We demonstrate our approach using an open-source implementation in\nour software visualization tool ExplorViz. ExplorViz is web-based and uses the\n3D city metaphor, focusing on live trace visualization.\n  We evaluated our approaches in two separate user studies. The results\nindicate that semantic zoom and the mini-map are both useful additions. User\nfeedback indicates that semantic zoom and mini-maps are especially useful for\nlarge software landscapes and collaborative software exploration. The studies\nindicate a good usability of our implemented approaches. However, some\nshortcomings in our implementations have also been discovered, to be addressed\nin future work.\n  Video URL: https://youtu.be/LYtUeWvizjU"}
{"id": "2510.00207", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2510.00207", "abs": "https://arxiv.org/abs/2510.00207", "authors": ["Yunqi Gao", "Bing Hu", "Mahdi Boloursaz Mashhadi", "A-Long Jin", "Yanfeng Zhang", "Pei Xiao", "Rahim Tafazolli", "Merouane Debbah"], "title": "FlowMoE: A Scalable Pipeline Scheduling Framework for Distributed Mixture-of-Experts Training", "comment": null, "summary": "The parameter size of modern large language models (LLMs) can be scaled up\nvia the sparsely-activated Mixture-of-Experts (MoE) technique to avoid\nexcessive increase of the computational costs. To further improve training\nefficiency, pipelining computation and communication has become a promising\nsolution for distributed MoE training. However, existing work primarily focuses\non scheduling tasks within the MoE layer, such as expert computing and\nall-to-all (A2A) communication, while neglecting other key operations including\nmulti-head attention (MHA) computing, gating, and all-reduce communication. In\nthis paper, we propose FlowMoE, a scalable framework for scheduling multi-type\ntask pipelines. First, FlowMoE constructs a unified pipeline to consistently\nscheduling MHA computing, gating, expert computing, and A2A communication.\nSecond, FlowMoE introduces a tensor chunk-based priority scheduling mechanism\nto overlap the all-reduce communication with all computing tasks. We implement\nFlowMoE as an adaptive and generic framework atop PyTorch. Extensive\nexperiments with 675 typical MoE layers and four real-world MoE models across\ntwo GPU clusters demonstrate that our proposed FlowMoE framework outperforms\nstate-of-the-art MoE training frameworks, reducing training time by 13%-57%,\nenergy consumption by 10%-39%, and memory usage by 7%-32%."}
{"id": "2510.00004", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.00004", "abs": "https://arxiv.org/abs/2510.00004", "authors": ["Malte Hansen", "David Moreno-Lumbreras", "Wilhelm Hasselbring"], "title": "HTML Structure Exploration in 3D Software Cities", "comment": "Copyright 2025 IEEE. Personal use of this material is permitted.\n  Permission from IEEE must be obtained for all other uses, in any current or\n  future media, including reprinting/republishing this material for advertising\n  or promotional purposes, creating new collective works, for resale or\n  redistribution to servers or lists, or reuse of any copyrighted component of\n  this work in other works", "summary": "Software visualization, which uses data from dynamic program analysis, can\nhelp to explore and understand the behavior of software systems. It is common\nthat large software systems offer a web interface for user interaction.\nUsually, available web interfaces are not regarded in software visualization\ntools. This paper introduces additions to the web-based live tracing software\nvisualization tool ExplorViz: We add an embedded web view for instrumented\napplications in the 3D visualization to ease interaction with the given\napplications and enable the exploration of the thereby displayed HTML content.\nNamely, the Document Object Model (DOM) is visualized via a three-dimensional\nrepresentation of the HTML structure in same-origin contexts.\n  Our visualization approach is evaluated in a preliminary user study. The\nstudy results give insights into the potential use cases, benefits, and\nshortcomings of our implemented approach. Based on our study results, we\npropose directions for further research to support the visual exploration of\nweb interfaces and explore use cases for the combined visualization of software\ncities and HTML structure.\n  Video URL: https://youtu.be/wBWKlbvzOOE"}
{"id": "2510.00306", "categories": ["cs.DC", "C.2.2; C.2.1; C.2.6; C.2.3; C.4"], "pdf": "https://arxiv.org/pdf/2510.00306", "abs": "https://arxiv.org/abs/2510.00306", "authors": ["Wenyang Jia", "Jingjing Wang", "Kai Lei"], "title": "BlockSDN-VC: A SDN-Based Virtual Coordinate-Enhanced Transaction Broadcast Framework for High-Performance Blockchains", "comment": "Accepted to IFIP International Conference on Network and Parallel\n  Computing (NPC 2025), LNCS format. Preprint. 12 pages", "summary": "Modern blockchains need fast, reliable propagation to balance security and\nthroughput. Virtual-coordinate methods speed dissemination but rely on slow\niterative updates, leaving nodes out of sync. We present BlockSDN-VC, a\ntransaction-broadcast protocol that centralises coordinate computation and\nforwarding control in an SDN controller, delivering global consistency, minimal\npath stretch and rapid response to churn or congestion. In geo-distributed\nsimulations, BlockSDN-VC cuts median latency by up to 62% and accelerates\nconvergence fourfold over state-of-the-art schemes with under 3% control-plane\noverhead. In a real blockchain environment, BlockSDN-VC boosts\nconfirmed-transaction throughput by 17% under adversarial workloads, requiring\nno modifications to existing clients."}
{"id": "2510.00031", "categories": ["cs.SE", "cs.AI", "cs.DC"], "pdf": "https://arxiv.org/pdf/2510.00031", "abs": "https://arxiv.org/abs/2510.00031", "authors": ["Shun-ichiro Hayashi", "Koki Morita", "Daichi Mukunoki", "Tetsuya Hoshino", "Takahiro Katagiri"], "title": "VibeCodeHPC: An Agent-Based Iterative Prompting Auto-Tuner for HPC Code Generation Using LLMs", "comment": null, "summary": "We propose VibeCodeHPC, an automatic tuning system for HPC programs based on\nmulti-agent LLMs for code generation. VibeCodeHPC tunes programs through\nmulti-agent role allocation and iterative prompt refinement. We describe the\nsystem configuration with four roles: Project Manager (PM), System Engineer\n(SE), Programmer (PG), and Continuous Delivery (CD). We introduce dynamic agent\ndeployment and activity monitoring functions to facilitate effective\nmulti-agent collaboration. In our case study, we convert and optimize CPU-based\nmatrix-matrix multiplication code written in C to GPU code using CUDA. The\nmulti-agent configuration of VibeCodeHPC achieved higher-quality code\ngeneration per unit time compared to a solo-agent configuration. Additionally,\nthe dynamic agent deployment and activity monitoring capabilities facilitated\nmore effective identification of requirement violations and other issues."}
{"id": "2510.00471", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2510.00471", "abs": "https://arxiv.org/abs/2510.00471", "authors": ["Yankai Jiang", "Raghavendra Kanakagiri", "Rohan Basu Roy", "Devesh Tiwari"], "title": "ThirstyFLOPS: Water Footprint Modeling and Analysis Toward Sustainable HPC Systems", "comment": null, "summary": "High-performance computing (HPC) systems are becoming increasingly\nwater-intensive due to their reliance on water-based cooling and the energy\nused in power generation. However, the water footprint of HPC remains\nrelatively underexplored-especially in contrast to the growing focus on carbon\nemissions. In this paper, we present ThirstyFLOPS - a comprehensive water\nfootprint analysis framework for HPC systems. Our approach incorporates\nregion-specific metrics, including Water Usage Effectiveness, Power Usage\nEffectiveness, and Energy Water Factor, to quantify water consumption using\nreal-world data. Using four representative HPC systems - Marconi, Fugaku,\nPolaris, and Frontier - as examples, we provide implications for HPC system\nplanning and management. We explore the impact of regional water scarcity and\nnuclear-based energy strategies on HPC sustainability. Our findings aim to\nadvance the development of water-aware, environmentally responsible computing\ninfrastructures."}
{"id": "2510.00092", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.00092", "abs": "https://arxiv.org/abs/2510.00092", "authors": ["Shufeng Chen", "Mariat James Elizebeth", "Robab Aghazadeh Chakherlou", "Xingyu Zhao", "Eric Barbier", "Siddartha Khastgir", "Paul Jennings"], "title": "A Scalable Framework for Safety Assurance of Self-Driving Vehicles based on Assurance 2.0", "comment": null, "summary": "Assurance 2.0 is a modern framework developed to address the assurance\nchallenges of increasingly complex, adaptive, and autonomous systems. Building\non the traditional Claims-Argument-Evidence (CAE) model, it introduces reusable\nassurance theories and explicit counterarguments (defeaters) to enhance rigor,\ntransparency, and adaptability. It supports continuous, incremental assurance,\nenabling innovation without compromising safety. However, limitations persist\nin confidence measurement, residual doubt management, automation support, and\nthe practical handling of defeaters and confirmation bias. This paper presents\n\\textcolor{black}{a set of decomposition frameworks to identify a complete set\nof safety arguments and measure their corresponding evidence.} Grounded in the\nAssurance 2.0 paradigm, the framework is instantiated through a structured\ntemplate and employs a three-tiered decomposition strategy. \\textcolor{black}{A\ncase study regarding the application of the decomposition framework in the\nend-to-end (E2E) AI-based Self-Driving Vehicle (SDV) development is also\npresented in this paper.} At the top level, the SDV development is divided into\nthree critical phases: Requirements Engineering (RE), Verification and\nValidation (VnV), and Post-Deployment (PD). Each phase is further decomposed\naccording to its Product Development Lifecycle (PDLC). To ensure comprehensive\ncoverage, each PDLC is analyzed using an adapted 5M1E model (Man, Machine,\nMethod, Material, Measurement, and Environment). Originally developed for\nmanufacturing quality control, the 5M1E model is reinterpreted and contextually\nmapped to the assurance domain. This enables a multi-dimensional decomposition\nthat supports fine-grained traceability of safety claims, evidence, and\npotential defeaters."}
{"id": "2510.00541", "categories": ["cs.DC", "68M20 (Performance evaluation, queueing, and scheduling), 90C59\n  (Approximation methods and heuristics)"], "pdf": "https://arxiv.org/pdf/2510.00541", "abs": "https://arxiv.org/abs/2510.00541", "authors": ["Ali M. Baydoun", "Ahmed S. Zekri"], "title": "Towards Efficient VM Placement: A Two-Stage ACO-PSO Approach for Green Cloud Infrastructure", "comment": "20 pages, 7 figures. Published in International Journal of Computer\n  Networks & Communications (IJCNC), Vol. 17, No. 5, 2025", "summary": "Datacenters consume a growing share of energy, prompting the need for\nsustainable resource management. This paper presents a Hybrid ACO-PSO (HAPSO)\nalgorithm for energy-aware virtual machine (VM) placement and migration in\ngreen cloud datacenters. In the first stage, Ant Colony Optimization (ACO)\nperforms energy-efficient initial placement across physical hosts, ensuring\nglobal feasibility. In the second stage, a discrete Particle Swarm Optimization\n(PSO) refines allocations by migrating VMs from overloaded or underutilized\nhosts. HAPSO introduces several innovations: sequential hybridization of\nmetaheuristics, system-informed particle initialization using ACO output,\nheuristic-guided discretization for constraint handling, and a multi-objective\nfitness function that minimizes active servers and resource wastage.\nImplemented in CloudSimPlus, extensive simulations demonstrate that HAPSO\nconsistently outperforms classical heuristics (BFD, FFD), Unified Ant Colony\nSystem (UACS), and ACO-only. Notably, HAPSO achieves up to 25% lower energy\nconsumption and 18% fewer SLA violations compared to UACS at large-scale\nworkloads, while sustaining stable cost and carbon emissions. These results\nhighlight the effectiveness of two-stage bio-inspired hybridization in\naddressing the dynamic and multi-objective nature of cloud resource management."}
{"id": "2510.00197", "categories": ["cs.SE", "D.2.11"], "pdf": "https://arxiv.org/pdf/2510.00197", "abs": "https://arxiv.org/abs/2510.00197", "authors": ["Diogo Maia", "Filipe Correia", "André Restivo", "Paulo Queiroz"], "title": "Container Orchestration Patterns for Optimizing Resource Use", "comment": null, "summary": "Service-based architectures provide substantial benefits, yet service\norchestration remains a challenge, particularly for newcomers. While various\nresources on orchestration techniques exist, they often lack clarity and\nstandardization, making best practices difficult to implement and limiting\ntheir adoption within the software industry.\n  To address this gap, we analyzed existing literature and tools to identify\ncommon orchestration practices. Based on our findings, we define three key\norchestration resource optimization patterns: {\\sc Preemptive Scheduling}, {\\sc\nService Balancing}, and {\\sc Garbage Collection}. {\\sc Preemptive Scheduling}\nallows the allocation of sufficient resources for services of higher priority\nin stressful situations, while {\\sc Service Balancing} enables a restructuring\nof the nodes to allow better resource usage. To end, {\\sc Garbage Collection}\ncreates cleanup mechanisms to better understand the system's resource usage and\noptimize it. These patterns serve as foundational elements for improving\norchestration practices and fostering broader adoption in service-based\narchitectures."}
{"id": "2510.00606", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2510.00606", "abs": "https://arxiv.org/abs/2510.00606", "authors": ["Xueze Kang", "Guangyu Xiang", "Yuxin Wang", "Hao Zhang", "Yuchu Fang", "Yuhang Zhou", "Zhenheng Tang", "Youhui Lv", "Eliran Maman", "Mark Wasserman", "Alon Zameret", "Zhipeng Bian", "Shushu Chen", "Zhiyou Yu", "Jin Wang", "Xiaoyu Wu", "Yang Zheng", "Chen Tian", "Xiaowen Chu"], "title": "ElasWave: An Elastic-Native System for Scalable Hybrid-Parallel Training", "comment": null, "summary": "Large-scale LLM pretraining today spans $10^{5}$--$10^{6}$ accelerators,\nmaking failures commonplace and elasticity no longer optional. We posit that an\nelastic-native training system must simultaneously ensure (i) Parameter\nConsistency, (ii) low Mean Time to Recovery (MTTR), (iii) high post-change\nThroughput, and (iv) Computation Consistency. This objective set not has never\nbeen jointly attained by prior work. To achieve these goals, we present\nElasWave, which provides per-step fault tolerance via multi-dimensional\nscheduling across Graph, Dataflow, Frequency, and Random Number Generation.\nElasWave resizes and reshards micro-batch workloads while preserving the global\nbatch size and gradient scale; it performs online pipeline resharding with\nasynchronous parameter migration, interleaving ZeRO partitions so recovery\nreduces to disjoint rank-to-rank transfers. It further uses DVFS to absorb\npipeline bubbles and reshards RNG to keep consistent computations. A dynamic\ncommunicator enables in-place communication group edits, while per-step\nin-memory snapshots support online verification and redistribution. We\nevaluated ElasWave on 96 NPUs and benchmarked against state-of-the-art\nbaselines: throughput improves by $1.35\\times$ over ReCycle and $1.60\\times$\nover TorchFT; communicator recovery completes within one second (up to\n$82\\times/3.6\\times$ faster than full/partial rebuilds); migration MTTR drops\nby as much as $51\\%$; and convergence deviation is reduced by approximately\n$78\\%$."}
{"id": "2510.00324", "categories": ["cs.SE", "cs.IR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.00324", "abs": "https://arxiv.org/abs/2510.00324", "authors": ["Lucas Roberts", "Denisa Roberts"], "title": "Which Programming Language and Model Work Best With LLM-as-a-Judge For Code Retrieval?", "comment": "Accepted as a full paper at SIGIR-AP 2025", "summary": "Code search is an important information retrieval application. Benefits of\nbetter code search include faster new developer on-boarding, reduced software\nmaintenance, and ease of understanding for large repositories. Despite\nimprovements in search algorithms and search benchmarks, the domain of code\nsearch has lagged behind. One reason is the high cost of human annotation for\ncode queries and answers. While humans may annotate search results in general\ntext QA systems, code annotations require specialized knowledge of a\nprogramming language (PL), as well as domain specific software engineering\nknowledge. In this work we study the use of Large Language Models (LLMs) to\nretrieve code at the level of functions and to generate annotations for code\nsearch results. We compare the impact of the retriever representation (sparse\nvs. semantic), programming language, and LLM by comparing human annotations\nacross several popular languages (C, Java, Javascript, Go, and Python). We\nfocus on repositories that implement common data structures likely to be\nimplemented in any PLs. For the same human annotations, we compare several\nLLM-as-a-Judge models to evaluate programming language and other affinities\nbetween LLMs. We find that the chosen retriever and PL exhibit affinities that\ncan be leveraged to improve alignment of human and AI relevance determinations,\nwith significant performance implications. We also find differences in\nrepresentation (sparse vs. semantic) across PLs that impact alignment of human\nand AI relevance determinations. We propose using transpilers to bootstrap\nscalable code search benchmark datasets in other PLs and in a case study\ndemonstrate that human-AI relevance agreement rates largely match the (worst\ncase) human-human agreement under study. The application code used in this work\nis available at \\href{https://github.com/rlucas7/code-searcher/}{this github\nrepo}."}
{"id": "2510.00678", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2510.00678", "abs": "https://arxiv.org/abs/2510.00678", "authors": ["Muhammad Ali Jamshed", "Malik Muhammad Saad", "Muhammad Ahmed Mohsin", "Dongkyun Kim", "Octavia A. Dobre", "Halim Yanikomeroglu", "Lina Mohjazi"], "title": "Net-Zero 6G from Earth to Orbit: Sustainable Design of Integrated Terrestrial and Non-Terrestrial Networks", "comment": "Submitted to IEEE Communications Magazine", "summary": "The integration of Terrestrial Networks (TN) and Non-Terrestrial Networks\n(NTN) plays a crucial role in bridging the digital divide and enabling Sixth\nGeneration (6G) and beyond to achieve truly ubiquitous connectivity. However,\ncombining TN and NTN introduces significant energy challenges due to the\ndiverse characteristics and operational environments of these systems. In this\npaper, we present for the first time a comprehensive overview of the design\nchallenges associated with achieving Net-Zero energy targets in integrated TN\nand NTN systems. We outline a set of key enabling technologies that can support\nthe energy demands of such networks while aligning with Net-Zero objectives. To\nenhance the Energy Efficiency (EE) of integrated TN and NTN systems, we provide\na use case analysis that leverages Artificial Intelligence (AI) to deliver\nadaptable solutions across diverse deployment scenarios. Finally, we highlight\npromising research directions that can guide the sustainable evolution of\nintegrated TN and NTN."}
{"id": "2510.00328", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.00328", "abs": "https://arxiv.org/abs/2510.00328", "authors": ["Ahmed Fawz", "Amjed Tahir", "Kelly Blincoe"], "title": "Vibe Coding in Practice: Motivations, Challenges, and a Future Outlook - a Grey Literature Review", "comment": null, "summary": "AI code generation tools are transforming software development, especially\nfor novice and non-software developers, by enabling them to write code and\nbuild applications faster and with little to no human intervention. Vibe coding\nis the practice where users rely on AI code generation tools through intuition\nand trial-and-error without necessarily understanding the underlying code.\nDespite widespread adoption, no research has systematically investigated why\nusers engage in vibe coding, what they experience while doing so, and how they\napproach quality assurance (QA) and perceive the quality of the AI-generated\ncode. To this end, we conduct a systematic grey literature review of 101\npractitioner sources, extracting 518 firsthand behavioral accounts about vibe\ncoding practices, challenges, and limitations. Our analysis reveals a\nspeed-quality trade-off paradox, where vibe coders are motivated by speed and\naccessibility, often experiencing rapid ``instant success and flow'', yet most\nperceive the resulting code as fast but flawed. QA practices are frequently\noverlooked, with many skipping testing, relying on the models' or tools'\noutputs without modification, or delegating checks back to the AI code\ngeneration tools. This creates a new class of vulnerable software developers,\nparticularly those who build a product but are unable to debug it when issues\narise. We argue that vibe coding lowers barriers and accelerates prototyping,\nbut at the cost of reliability and maintainability. These insights carry\nimplications for tool designers and software development teams. Understanding\nhow vibe coding is practiced today is crucial for guiding its responsible use\nand preventing a broader QA crisis in AI-assisted development."}
{"id": "2510.00758", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2510.00758", "abs": "https://arxiv.org/abs/2510.00758", "authors": ["Davide Rucci", "Emanuele Carlini", "Patrizio Dazzi", "Hanna Kavalionak", "Matteo Mordacchini"], "title": "Decentralized and Self-adaptive Core Maintenance on Temporal Graphs", "comment": null, "summary": "Key graph-based problems play a central role in understanding network\ntopology and uncovering patterns of similarity in homogeneous and temporal\ndata. Such patterns can be revealed by analyzing communities formed by nodes,\nwhich in turn can be effectively modeled through temporal $k$-cores. This paper\nintroduces a novel decentralized and incremental algorithm for computing the\ncore decomposition of temporal networks. Decentralized solutions leverage the\nability of network nodes to communicate and coordinate locally, addressing\ncomplex problems in a scalable, adaptive, and timely manner. By leveraging\npreviously computed coreness values, our approach significantly reduces the\nactivation of nodes and the volume of message exchanges when the network\nchanges over time. This enables scalability with only a minimal trade-off in\nprecision. Experimental evaluations on large real-world networks under varying\nlevels of dynamism demonstrate the efficiency of our solution compared to a\nstate-of-the-art approach, particularly in terms of active nodes, communication\noverhead, and convergence speed."}
{"id": "2510.00450", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.00450", "abs": "https://arxiv.org/abs/2510.00450", "authors": ["Sheikh Md. Mushfiqur Rahman", "Nasir Eisty"], "title": "Beyond Pass/Fail: The Story of Learning-Based Testing", "comment": null, "summary": "Learning-Based Testing (LBT) merges learning and testing processes to achieve\nboth testing and behavioral adequacy. LBT utilizes active learning to infer the\nmodel of the System Under Test (SUT), enabling scalability for large and\ncomplex programs by requiring only a minimal set of initial test cases. The\ncore principle of LBT is that the SUT's behavior can be thoroughly inferred by\nprogressively generating test cases and subjecting the SUT to testing, thereby\nensuring comprehensive testing. Despite being in its early stages, LBT has a\nsolid foundation of theoretical research demonstrating its efficacy in testing\nboth procedural and reactive programs. This paper provides a systematic\nliterature review of various LBT implementations across different program types\nand evaluates the current state of research in this field. We explore diverse\ntheoretical frameworks, existing tools, and libraries within the LBT domain to\nillustrate the concept's evolution and current research status. Additionally,\nwe examine case studies involving the application of LBT tools in industrial\nsettings, highlighting their potential and effectiveness in commercial software\ntesting. This systematic literature review aims to offer researchers a\ncomprehensive perspective on the inception and development of LBT, presenting\nit as a promising technique in software testing. By unveiling LBT's\nunderutilized potential, this paper seeks to significantly benefit the\npractitioners and research community."}
{"id": "2510.00822", "categories": ["cs.DC", "cs.PF"], "pdf": "https://arxiv.org/pdf/2510.00822", "abs": "https://arxiv.org/abs/2510.00822", "authors": ["Sairam Sri Vatsavai", "Raees Khan", "Kuan-Chieh Hsu", "Ozgur O. Kilic", "Paul Nilsson", "Tatiana Korchuganova", "David K. Park", "Sankha Dutta", "Yihui Ren", "Joseph Boudreau", "Tasnuva Chowdhury", "Shengyu Feng", "Jaehyung Kim", "Scott Klasky", "Tadashi Maeno", "Verena Ingrid Martinez", "Norbert Podhorszki", "Frédéric Suter", "Wei Yang", "Yiming Yang", "Shinjae Yoo", "Alexei Klimentov", "Adolfy Hoisie"], "title": "CGSim: A Simulation Framework for Large Scale Distributed Computing Environment", "comment": "The paper has been accepted at PMBS workshop SC25", "summary": "Large-scale distributed computing infrastructures such as the Worldwide LHC\nComputing Grid (WLCG) require comprehensive simulation tools for evaluating\nperformance, testing new algorithms, and optimizing resource allocation\nstrategies. However, existing simulators suffer from limited scalability,\nhardwired algorithms, lack of real-time monitoring, and inability to generate\ndatasets suitable for modern machine learning approaches. We present CGSim, a\nsimulation framework for large-scale distributed computing environments that\naddresses these limitations. Built upon the validated SimGrid simulation\nframework, CGSim provides high-level abstractions for modeling heterogeneous\ngrid environments while maintaining accuracy and scalability. Key features\ninclude a modular plugin mechanism for testing custom workflow scheduling and\ndata movement policies, interactive real-time visualization dashboards, and\nautomatic generation of event-level datasets suitable for AI-assisted\nperformance modeling. We demonstrate CGSim's capabilities through a\ncomprehensive evaluation using production ATLAS PanDA workloads, showing\nsignificant calibration accuracy improvements across WLCG computing sites.\nScalability experiments show near-linear scaling for multi-site simulations,\nwith distributed workloads achieving 6x better performance compared to\nsingle-site execution. The framework enables researchers to simulate WLCG-scale\ninfrastructures with hundreds of sites and thousands of concurrent jobs within\npractical time budget constraints on commodity hardware."}
{"id": "2510.00476", "categories": ["cs.SE", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.00476", "abs": "https://arxiv.org/abs/2510.00476", "authors": ["Arushi Sharma", "Vedant Pungliya", "Christopher J. Quinn", "Ali Jannesari"], "title": "Analyzing Latent Concepts in Code Language Models", "comment": null, "summary": "Interpreting the internal behavior of large language models trained on code\nremains a critical challenge, particularly for applications demanding trust,\ntransparency, and semantic robustness. We propose Code Concept Analysis\n(CoCoA): a global post-hoc interpretability framework that uncovers emergent\nlexical, syntactic, and semantic structures in a code language model's\nrepresentation space by clustering contextualized token embeddings into\nhuman-interpretable concept groups. We propose a hybrid annotation pipeline\nthat combines static analysis tool-based syntactic alignment with\nprompt-engineered large language models (LLMs), enabling scalable labeling of\nlatent concepts across abstraction levels. We analyse the distribution of\nconcepts across layers and across three finetuning tasks. Emergent concept\nclusters can help identify unexpected latent interactions and be used to\nidentify trends and biases within the model's learned representations. We\nfurther integrate LCA with local attribution methods to produce\nconcept-grounded explanations, improving the coherence and interpretability of\ntoken-level saliency. Empirical evaluations across multiple models and tasks\nshow that LCA discovers concepts that remain stable under semantic-preserving\nperturbations (average Cluster Sensitivity Index, CSI = 0.288) and evolve\npredictably with fine-tuning. In a user study, concept-augmented explanations\ndisambiguate token roles. In a user study on the programming-language\nclassification task, concept-augmented explanations disambiguated token roles\nand improved human-centric explainability by 37 percentage points compared with\ntoken-level attributions using Integrated Gradients."}
{"id": "2510.00828", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2510.00828", "abs": "https://arxiv.org/abs/2510.00828", "authors": ["Kuan-Chieh Hsu", "Sairam Sri Vatsavai", "Ozgur O. Kilic", "Tatiana Korchuganova", "Paul Nilsson", "Sankha Dutta", "Yihui Ren", "David K. Park", "Joseph Boudreau", "Tasnuva Chowdhury", "Shengyu Feng", "Raees Khan", "Jaehyung Kim", "Scott Klasky", "Tadashi Maeno", "Verena Ingrid Martinez Outschoorn", "Norbert Podhorszki", "Frédéric Suter", "Wei Yang", "Yiming Yang", "Shinjae Yoo", "Alexei Klimentov", "Adolfy Hoisie"], "title": "Data Management System Analysis for Distributed Computing Workloads", "comment": "10 pages, 12 figures, to be presented in SC25 DRBSD Workshop", "summary": "Large-scale international collaborations such as ATLAS rely on globally\ndistributed workflows and data management to process, move, and store vast\nvolumes of data. ATLAS's Production and Distributed Analysis (PanDA) workflow\nsystem and the Rucio data management system are each highly optimized for their\nrespective design goals. However, operating them together at global scale\nexposes systemic inefficiencies, including underutilized resources, redundant\nor unnecessary transfers, and altered error distributions. Moreover, PanDA and\nRucio currently lack shared performance awareness and coordinated, adaptive\nstrategies.\n  This work charts a path toward co-optimizing the two systems by diagnosing\ndata-management pitfalls and prioritizing end-to-end improvements. With the\nobservation of spatially and temporally imbalanced transfer activities, we\ndevelop a metadata-matching algorithm that links PanDA jobs and Rucio datasets\nat the file level, yielding a complete, fine-grained view of data access and\nmovement. Using this linkage, we identify anomalous transfer patterns that\nviolate PanDA's data-centric job-allocation principle. We then outline\nmitigation strategies for these patterns and highlight opportunities for\ntighter PanDA-Rucio coordination to improve resource utilization, reduce\nunnecessary data movement, and enhance overall system resilience."}
{"id": "2510.00501", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.00501", "abs": "https://arxiv.org/abs/2510.00501", "authors": ["Kaixin Wang", "Tianlin Li", "Xiaoyu Zhang", "Aishan Liu", "Xianglong Liu", "Ziqi Liu", "Zhiqiang Zhang", "Jun Zhou", "and Bin Shi"], "title": "CodeChemist: Functional Knowledge Transfer for Low-Resource Code Generation via Test-Time Scaling", "comment": null, "summary": "Code Large Language Models (CodeLLMs) are increasingly used in code\ngeneration tasks across a wide range of applications. However, their\nperformance is often inconsistent across different programming languages (PLs),\nwith low-resource PLs suffering the most due to limited training data. In this\npaper, we present CodeChemist, a novel and efficient framework for test-time\nscaling that enables functional knowledge transfer from high-resource to\nlow-resource PLs using generated test cases. CodeChemist first generates and\nexecutes code in high-resource PLs to create test cases that encapsulate\nfunctional knowledge. It then uses multi-temperature hedged sampling to\ngenerate code snippets in the low-resource PL and selects the best one based on\nthe pass rate of the test cases. Our extensive experiments show that\nCodeChemist outperforms existing test-time scaling approaches, boosting the\nperformance of code generation for low-resource PLs without requiring any model\nretraining."}
{"id": "2510.00833", "categories": ["cs.DC", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.00833", "abs": "https://arxiv.org/abs/2510.00833", "authors": ["Thanh Linh Nguyen", "Marcela Tuler de Oliveira", "An Braeken", "Aaron Yi Ding", "Quoc-Viet Pham"], "title": "Towards Verifiable Federated Unlearning: Framework, Challenges, and The Road Ahead", "comment": "Journal submission", "summary": "Federated unlearning (FUL) enables removing the data influence from the model\ntrained across distributed clients, upholding the right to be forgotten as\nmandated by privacy regulations. FUL facilitates a value exchange where clients\ngain privacy-preserving control over their data contributions, while service\nproviders leverage decentralized computing and data freshness. However, this\nentire proposition is undermined because clients have no reliable way to verify\nthat their data influence has been provably removed, as current metrics and\nsimple notifications offer insufficient assurance. We envision unlearning\nverification becoming a pivotal and trust-by-design part of the FUL life-cycle\ndevelopment, essential for highly regulated and data-sensitive services and\napplications like healthcare. This article introduces veriFUL, a reference\nframework for verifiable FUL that formalizes verification entities, goals,\napproaches, and metrics. Specifically, we consolidate existing efforts and\ncontribute new insights, concepts, and metrics to this domain. Finally, we\nhighlight research challenges and identify potential applications and\ndevelopments for verifiable FUL and veriFUL."}
{"id": "2510.00519", "categories": ["cs.SE", "cs.AI", "D.2.4; D.2.11"], "pdf": "https://arxiv.org/pdf/2510.00519", "abs": "https://arxiv.org/abs/2510.00519", "authors": ["Hadiza Umar Yusuf", "Khouloud Gaaloul"], "title": "Architectural Transformations and Emerging Verification Demands in AI-Enabled Cyber-Physical Systems", "comment": null, "summary": "In the world of Cyber-Physical Systems (CPS), a captivating real-time fusion\noccurs where digital technology meets the physical world. This synergy has been\nsignificantly transformed by the integration of artificial intelligence (AI), a\nmove that dramatically enhances system adaptability and introduces a layer of\ncomplexity that impacts CPS control optimization and reliability. Despite\nadvancements in AI integration, a significant gap remains in understanding how\nthis shift affects CPS architecture, operational complexity, and verification\npractices. The extended abstract addresses this gap by investigating\narchitectural distinctions between AI-driven and traditional control models\ndesigned in Simulink and their respective implications for system verification."}
{"id": "2510.00991", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2510.00991", "abs": "https://arxiv.org/abs/2510.00991", "authors": ["Ziteng Chen", "Xiaohe Hu", "Menghao Zhang", "Yanmin Jia", "Yan Zhang", "Mingjun Zhang", "Da Liu", "Fangzheng Jiao", "Jun Chen", "He Liu", "Aohan Zeng", "Shuaixing Duan", "Ruya Gu", "Yang Jing", "Bowen Han", "Jiahao Cao", "Wei Chen", "Wenqi Xie", "Jinlong Hou", "Yuan Cheng", "Bohua Xu", "Mingwei Xu", "Chunming Hu"], "title": "An Efficient, Reliable and Observable Collective Communication Library in Large-scale GPU Training Clusters", "comment": "15 pages, 16 figures", "summary": "Large-scale LLM training requires collective communication libraries to\nexchange data among distributed GPUs. As a company dedicated to building and\noperating large-scale GPU training clusters, we encounter several challenges\nwhen using NCCL in production, including 1) limited efficiency with costly and\ncumbersome P2P communication, 2) poor tolerance to frequent RNIC port failures,\nand 3) insufficient observability of transient collective communication\nanomalies. To address these issues, we propose ICCL, an efficient, reliable,\nand observable collective communication library in large-scale GPU training\nclusters. ICCL offloads the P2P communication from GPU kernels to CPU threads\nfor minimal SM consumption, and removes the redundant memory copies irrelevant\nto the actual communicating process. ICCL also introduces a primary-backup QP\nmechanism to tolerate frequent NIC port failures, and designs a window-based\nmonitor to observe network anomalies at O(us) level. We open-source ICCL and\ndeploy it in production training clusters for several months, with results\nshowing that compared to NCCL, ICCL achieves a 23.4%/28.5% improvement in P2P\nthroughput/latency as well as a 6.02% increase in training throughput. We also\nshare the operating experience of ICCL in large-scale clusters, hoping to give\nthe communities more insights on production-level collective communication\nlibraries in LLM training."}
{"id": "2510.00532", "categories": ["cs.SE", "cs.CR", "D.2.5"], "pdf": "https://arxiv.org/pdf/2510.00532", "abs": "https://arxiv.org/abs/2510.00532", "authors": ["Hengcheng Zhu", "Songqiang Chen", "Valerio Terragni", "Lili Wei", "Jiarong Wu", "Yepang Liu", "Shing-Chi Cheung"], "title": "LSPFuzz: Hunting Bugs in Language Servers", "comment": "This paper has been accepted for publication in The 40th IEEE/ACM\n  International Conference on Automated Software Engineering (ASE 2025)", "summary": "The Language Server Protocol (LSP) has revolutionized the integration of code\nintelligence in modern software development. There are approximately 300 LSP\nserver implementations for various languages and 50 editors offering LSP\nintegration. However, the reliability of LSP servers is a growing concern, as\ncrashes can disable all code intelligence features and significantly impact\nproductivity, while vulnerabilities can put developers at risk even when\nediting untrusted source code. Despite the widespread adoption of LSP, no\nexisting techniques specifically target LSP server testing. To bridge this gap,\nwe present LSPFuzz, a grey-box hybrid fuzzer for systematic LSP server testing.\nOur key insight is that effective LSP server testing requires holistic mutation\nof source code and editor operations, as bugs often manifest from their\ncombinations. To satisfy the sophisticated constraints of LSP and effectively\nexplore the input space, we employ a two-stage mutation pipeline: syntax-aware\nmutations to source code, followed by context-aware dispatching of editor\noperations. We evaluated LSPFuzz on four widely used LSP servers. LSPFuzz\ndemonstrated superior performance compared to baseline fuzzers, and uncovered\npreviously unknown bugs in real-world LSP servers. Of the 51 bugs we reported,\n42 have been confirmed, 26 have been fixed by developers, and two have been\nassigned CVE numbers. Our work advances the quality assurance of LSP servers,\nproviding both a practical tool and foundational insights for future research\nin this domain."}
{"id": "2510.00031", "categories": ["cs.SE", "cs.AI", "cs.DC"], "pdf": "https://arxiv.org/pdf/2510.00031", "abs": "https://arxiv.org/abs/2510.00031", "authors": ["Shun-ichiro Hayashi", "Koki Morita", "Daichi Mukunoki", "Tetsuya Hoshino", "Takahiro Katagiri"], "title": "VibeCodeHPC: An Agent-Based Iterative Prompting Auto-Tuner for HPC Code Generation Using LLMs", "comment": null, "summary": "We propose VibeCodeHPC, an automatic tuning system for HPC programs based on\nmulti-agent LLMs for code generation. VibeCodeHPC tunes programs through\nmulti-agent role allocation and iterative prompt refinement. We describe the\nsystem configuration with four roles: Project Manager (PM), System Engineer\n(SE), Programmer (PG), and Continuous Delivery (CD). We introduce dynamic agent\ndeployment and activity monitoring functions to facilitate effective\nmulti-agent collaboration. In our case study, we convert and optimize CPU-based\nmatrix-matrix multiplication code written in C to GPU code using CUDA. The\nmulti-agent configuration of VibeCodeHPC achieved higher-quality code\ngeneration per unit time compared to a solo-agent configuration. Additionally,\nthe dynamic agent deployment and activity monitoring capabilities facilitated\nmore effective identification of requirement violations and other issues."}
{"id": "2510.00591", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.00591", "abs": "https://arxiv.org/abs/2510.00591", "authors": ["Liyi Cai", "Yijie Ren", "Yitong Zhang", "Jia Li"], "title": "AI-Driven Self-Evolving Software: A Promising Path Toward Software Automation", "comment": null, "summary": "Software automation has long been a central goal of software engineering,\nstriving for software development that proceeds without human intervention.\nRecent efforts have leveraged Artificial Intelligence (AI) to advance software\nautomation with notable progress. However, current AI functions primarily as\nassistants to human developers, leaving software development still dependent on\nexplicit human intervention. This raises a fundamental question: Can AI move\nbeyond its role as an assistant to become a core component of software, thereby\nenabling genuine software automation? To investigate this vision, we introduce\nAI-Driven Self-Evolving Software, a new form of software that evolves\ncontinuously through direct interaction with users. We demonstrate the\nfeasibility of this idea with a lightweight prototype built on a multi-agent\narchitecture that autonomously interprets user requirements, generates and\nvalidates code, and integrates new functionalities. Case studies across\nmultiple representative scenarios show that the prototype can reliably\nconstruct and reuse functionality, providing early evidence that such software\nsystems can scale to more sophisticated applications and pave the way toward\ntruly automated software development. We make code and cases in this work\npublicly available at https://anonymous.4open.science/r/live-software."}
{"id": "2510.00674", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.00674", "abs": "https://arxiv.org/abs/2510.00674", "authors": ["Konstantinos Karakatsanis", "Georgios Alexopoulos", "Ioannis Karyotakis", "Foivos Timotheos Proestakis", "Evangelos Talos", "Panos Louridas", "Dimitris Mitropoulos"], "title": "PyTrim: A Practical Tool for Reducing Python Dependency Bloat", "comment": "Accepted at ASE 2025 (Tool Demonstration Track)", "summary": "Dependency bloat is a persistent challenge in Python projects, which\nincreases maintenance costs and security risks. While numerous tools exist for\ndetecting unused dependencies in Python, removing these dependencies across the\nsource code and configuration files of a project requires manual effort and\nexpertise.\n  To tackle this challenge we introduce PYTRIM, an end-to-end system to\nautomate this process. PYTRIM eliminates unused imports and package\ndeclarations across a variety of file types, including Python source and\nconfiguration files such as requirements.txt and setup.py. PYTRIM's modular\ndesign makes it agnostic to the source of dependency bloat information,\nenabling integration with any detection tool. Beyond its contribution when it\ncomes to automation, PYTRIM also incorporates a novel dynamic analysis\ncomponent that improves dependency detection recall.\n  Our evaluation of PYTRIM's end-to-end effectiveness on a ground-truth dataset\nof 37 merged pull requests from prior work, shows that PYTRIM achieves 98.3%\naccuracy in replicating human-made changes. To show its practical impact, we\nrun PYTRIM on 971 open-source packages, identifying and trimming bloated\ndependencies in 39 of them. For each case, we submit a corresponding pull\nrequest, 6 of which have already been accepted and merged. PYTRIM is available\nas an open-source project, encouraging community contributions and further\ndevelopment.\n  Video demonstration: https://youtu.be/LqTEdOUbJRI\n  Code repository: https://github.com/TrimTeam/PyTrim"}
{"id": "2510.00680", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.00680", "abs": "https://arxiv.org/abs/2510.00680", "authors": ["Hang Cui", "Jingjing Li", "Haotian Si", "Quan Zhou", "Changhua Pei", "Gaogang Xie", "Dan Pei"], "title": "TShape: Rescuing Machine Learning Models from Complex Shapelet Anomalies", "comment": null, "summary": "Time series anomaly detection (TSAD) is critical for maintaining the\nreliability of modern IT infrastructures, where complex anomalies frequently\narise in highly dynamic environments. In this paper, we present TShape, a novel\nframework designed to address the challenges in industrial time series anomaly\ndetection. Existing methods often struggle to detect shapelet anomalies that\nmanifest as complex shape deviations, which appear obvious to human experts but\nprove challenging for machine learning algorithms. TShape introduces a\npatch-wise dual attention mechanism with multi-scale convolution to model\nintricate sub-sequence variations by balancing local, fine-grained shape\nfeatures with global contextual dependencies. Our extensive evaluation on five\ndiverse benchmarks demonstrates that TShape outperforms existing\nstate-of-the-art models, achieving an average 10\\% F1 score improvement in\nanomaly detection. Additionally, ablation studies and attention visualizations\nconfirm the essential contributions of each component, highlighting the\nrobustness and adaptability of TShape to complex shapelet shapes in time series\ndata."}
{"id": "2510.00730", "categories": ["cs.SE", "cs.CR"], "pdf": "https://arxiv.org/pdf/2510.00730", "abs": "https://arxiv.org/abs/2510.00730", "authors": ["Larissa Schmid", "Elias Lundell", "Yogya Gamage", "Benoit Baudry", "Martin Monperrus"], "title": "Maven-Lockfile: High Integrity Rebuild of Past Java Releases", "comment": null, "summary": "Modern software projects depend on many third-party libraries, complicating\nreproducible and secure builds. Several package managers address this with the\ngeneration of a lockfile that freezes dependency versions and can be used to\nverify the integrity of dependencies. Yet, Maven, one of the most important\npackage managers in the Java ecosystem, lacks native support for a lockfile. We\npresent Maven-Lockfile to generate and update lockfiles, with support for\nrebuilding projects from past versions. Our lockfiles capture all direct and\ntransitive dependencies with their checksums, enabling high integrity builds.\nOur evaluation shows that Maven-Lockfile can reproduce builds from historical\ncommits and is able to detect tampered artifacts. With minimal configuration,\nMaven-Lockfile equips Java projects with modern build integrity and build\nreproducibility, and fosters future research on software supply chain security\nin Java."}
{"id": "2510.00762", "categories": ["cs.SE", "cs.HC"], "pdf": "https://arxiv.org/pdf/2510.00762", "abs": "https://arxiv.org/abs/2510.00762", "authors": ["Rudrajit Choudhuri", "Carmen Badea", "Christian Bird", "Jenna Butler", "Rob DeLine", "Brian Houck"], "title": "AI Where It Matters: Where, Why, and How Developers Want AI Support in Daily Work", "comment": null, "summary": "Generative AI is reshaping software work, yet we lack clear guidance on where\ndevelopers most need and want support, and how to design it responsibly. We\nreport a large-scale, mixed-methods study of N=860 developers that examines\nwhere, why, and how they seek or limit AI help, providing the first task-aware,\nempirically validated mapping from developers' perceptions of their tasks to AI\nadoption patterns and responsible AI priorities. Using cognitive appraisal\ntheory, we show that task evaluations predict openness to and use of AI,\nrevealing distinct patterns: strong current use and a desire for improvement in\ncore work (e.g., coding, testing); high demand to reduce toil (e.g.,\ndocumentation, operations); and clear limits for identity- and\nrelationship-centric work (e.g., mentoring). Priorities for responsible AI\nsupport vary by context: reliability and security for systems-facing tasks;\ntransparency, alignment, and steerability to maintain control; and fairness and\ninclusiveness for human-facing work. Our results offer concrete, contextual\nguidance for delivering AI where it matters to developers and their work."}
{"id": "2510.00881", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.00881", "abs": "https://arxiv.org/abs/2510.00881", "authors": ["Patrizio Migliarini", "Mashal Afzal Memon", "Marco Autili", "Paola Inverardi"], "title": "Advancing Automated Ethical Profiling in SE: a Zero-Shot Evaluation of LLM Reasoning", "comment": "Accepted at ASE 2025", "summary": "Large Language Models (LLMs) are increasingly integrated into software\nengineering (SE) tools for tasks that extend beyond code synthesis, including\njudgment under uncertainty and reasoning in ethically significant contexts. We\npresent a fully automated framework for assessing ethical reasoning\ncapabilities across 16 LLMs in a zero-shot setting, using 30 real-world\nethically charged scenarios. Each model is prompted to identify the most\napplicable ethical theory to an action, assess its moral acceptability, and\nexplain the reasoning behind their choice. Responses are compared against\nexpert ethicists' choices using inter-model agreement metrics. Our results show\nthat LLMs achieve an average Theory Consistency Rate (TCR) of 73.3% and Binary\nAgreement Rate (BAR) on moral acceptability of 86.7%, with interpretable\ndivergences concentrated in ethically ambiguous cases. A qualitative analysis\nof free-text explanations reveals strong conceptual convergence across models\ndespite surface-level lexical diversity. These findings support the potential\nviability of LLMs as ethical inference engines within SE pipelines, enabling\nscalable, auditable, and adaptive integration of user-aligned ethical\nreasoning. Our focus is the Ethical Interpreter component of a broader\nprofiling pipeline: we evaluate whether current LLMs exhibit sufficient\ninterpretive stability and theory-consistent reasoning to support automated\nprofiling."}
{"id": "2510.00920", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.00920", "abs": "https://arxiv.org/abs/2510.00920", "authors": ["Songqiang Chen", "Congying Xu", "Jingyi Chen", "Jialun Cao", "Jiarong Wu", "Shing-Chi Cheung"], "title": "On Effective Semantic Translation for Code: A Study Based on Pseudocode", "comment": null, "summary": "Large language models (LLMs) show great potential in code translation.\nHowever, accurate translation remains challenging when using the commonly\nadopted direct code-to-code translation approach, which converts a program into\nthe target programming language (PL) in a single step. Inspired by the success\nof incorporating intermediate steps to guide LLMs in resolving challenging\ntasks, we explore pseudocode-based code translation, which emulates the human\nsemantic translation by first interpreting the program's intent and logic into\npseudocode and then implementing it in the target PL. We find that\npseudocode-based translation helps translate programs that direct translation\nstruggles to handle. Nonetheless, the effectiveness, advantages, and\nlimitations of this approach remain underexplored. To bridge this gap, we\npresent an empirical study on pseudocode-based code translation, aiming to\ninvestigate its effectiveness in enhancing the direct translation approach,\nilluminate its effective usage, and identify limitations hindering its\npotential benefits. By comparing direct and pseudocode-based translation\napproaches on 9,690 translation tasks across six PLs with five popular LLMs, we\ndemonstrate that pseudocode-based translation can effectively complement direct\ntranslation, particularly when translating from flexible to rigid PLs or\ndealing with low-resource Rust. Based on these findings, we suggest adopting\nstrategies that combine the complementary strengths of both approaches to\nenhance code translation accuracy. We also reveal the advantages of\npseudocode-based translation in disentangling translations of complicated\nprograms and mitigating distractions from detailed implementations in original\nprograms, as well as its limitations due to incorrect, incomplete, or ambiguous\npseudocode."}
{"id": "2510.00946", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.00946", "abs": "https://arxiv.org/abs/2510.00946", "authors": ["Shiza Andleeb", "Brandon Kantorski", "Jeffrey C. Carver"], "title": "ChatGPT in Introductory Programming: Counterbalanced Evaluation of Code Quality, Conceptual Learning, and Student Perceptions", "comment": "Accepted to SIGCITE'25", "summary": "Background: Large language models (LLMs) such as ChatGPT are increasingly\nused in introductory programming courses to provide real-time code generation,\ndebugging, and explanations. While these tools can boost productivity and code\nquality, concerns remain about over-reliance and potential impacts on\nconceptual learning. Objective: To investigate how ChatGPT access affects code\nquality, conceptual understanding, task completion times, and student\nperceptions in a CS1 course. Methods: We conducted a counterbalanced,\nquasi-experimental study in which students alternated between ChatGPT and\nnon-ChatGPT conditions across two programming assignments in C (functions and\nstructures). We evaluated their code submissions using multidimensional\nrubrics, conceptual post-surveys, and task completion time. Results: Students\nwho had access to ChatGPT produced significantly higher rubric scores for code\nquality and completed tasks in less time compared to those without access.\nHowever, gains in conceptual understanding were mixed, lower for the functions\ntopic but higher for the structures topic. Students reported positive\nexperiences with ChatGPT, citing its value for debugging and practice, while\nexpressing concerns about accuracy and long-term skill development.\nConclusions: ChatGPT can enhance code quality and efficiency for novice\nprogrammers, but may not uniformly improve conceptual understanding. Structured\nintegration and complementary instructional strategies are recommended to\nfoster independent problem-solving skills."}
{"id": "2510.00957", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.00957", "abs": "https://arxiv.org/abs/2510.00957", "authors": ["Shiza Andleeb", "Teo Mendoza", "Lucas Cordova", "Gursimran Walia", "Jeffrey C. Carver"], "title": "Enhancing Software Testing Education: Understanding Where Students Struggle", "comment": "Accepted to SIGCITE'25", "summary": "Effective software testing is critical for producing reliable and secure\nsoftware, yet many computer science students struggle to master the\nfoundational concepts required to construct comprehensive test suites. While\nautomated feedback tools are widely used to support student learning, it\nremains unclear which testing concepts are most frequently misunderstood and\nhow these misunderstandings are reflected in students' test suite revisions.\nThis study examines the specific testing concepts that lead students to make\nineffective changes, those that fail to improve code coverage, during test\nsuite development. Leveraging an automated feedback tool in a senior-level\nsoftware testing course, we analyzed student submissions from two assignments\nto identify prevalent conceptual gaps and patterns of unproductive\nmodification. Our results reveal that decision coverage and exception handling\nare persistent challenges, and that students most often make superficial or\nmethod-level changes that do not enhance coverage. These findings provide\nactionable insights for educators, researchers, and tool designers. By\npinpointing the concepts that most often contribute to poor testing outcomes,\nwe can refine feedback systems, target instruction to address persistent\nmisconceptions, and more effectively support students in developing robust,\nmaintainable test suites."}
{"id": "2510.01002", "categories": ["cs.SE", "cs.CR"], "pdf": "https://arxiv.org/pdf/2510.01002", "abs": "https://arxiv.org/abs/2510.01002", "authors": ["Chengran Yang", "Ting Zhang", "Jinfeng Jiang", "Xin Zhou", "Haoye Tian", "Jieke Shi", "Junkai Chen", "Yikun Li", "Eng Lieh Ouh", "Lwin Khin Shar", "David Lo"], "title": "Semantics-Aligned, Curriculum-Driven, and Reasoning-Enhanced Vulnerability Repair Framework", "comment": null, "summary": "Current learning-based Automated Vulnerability Repair (AVR) approaches, while\npromising, often fail to generalize effectively in real-world scenarios. Our\ndiagnostic analysis reveals three fundamental weaknesses in state-of-the-art\nAVR approaches: (1) limited cross-repository generalization, with performance\ndrops on unseen codebases; (2) inability to capture long-range dependencies,\ncausing a performance degradation on complex, multi-hunk repairs; and (3)\nover-reliance on superficial lexical patterns, leading to significant\nperformance drops on vulnerabilities with minor syntactic variations like\nvariable renaming.\n  To address these limitations, we propose SeCuRepair, a semantics-aligned,\ncurriculum-driven, and reasoning-enhanced framework for vulnerability repair.\nAt its core, SeCuRepair adopts a reason-then-edit paradigm, requiring the model\nto articulate why and how a vulnerability should be fixed before generating the\npatch. This explicit reasoning enforces a genuine understanding of repair logic\nrather than superficial memorization of lexical patterns. SeCuRepair also moves\nbeyond traditional supervised fine-tuning and employs semantics-aware\nreinforcement learning, rewarding patches for their syntactic and semantic\nalignment with the oracle patch rather than mere token overlap. Complementing\nthis, a difficulty-aware curriculum progressively trains the model, starting\nwith simple fixes and advancing to complex, multi-hunk coordinated edits.\n  We evaluate SeCuRepair on strict, repository-level splits of BigVul and newly\ncrafted PrimeVul_AVR datasets. SeCuRepair significantly outperforms all\nbaselines, surpassing the best-performing baselines by 34.52% on BigVul and\n31.52% on PrimeVul\\textsubscript{AVR} in terms of CodeBLEU, respectively.\nComprehensive ablation studies further confirm that each component of our\nframework contributes to its final performance."}
{"id": "2510.01003", "categories": ["cs.SE", "cs.CL"], "pdf": "https://arxiv.org/pdf/2510.01003", "abs": "https://arxiv.org/abs/2510.01003", "authors": ["Boshi Wang", "Weijian Xu", "Yunsheng Li", "Mei Gao", "Yujia Xie", "Huan Sun", "Dongdong Chen"], "title": "Improving Code Localization with Repository Memory", "comment": "15 pages, 8 figures", "summary": "Code localization is a fundamental challenge in repository-level software\nengineering tasks such as bug fixing. While existing methods equip language\nagents with comprehensive tools/interfaces to fetch information from the\nrepository, they overlook the critical aspect of memory, where each instance is\ntypically handled from scratch assuming no prior repository knowledge. In\ncontrast, human developers naturally build long-term repository memory, such as\nthe functionality of key modules and associations between various bug types and\ntheir likely fix locations. In this work, we augment language agents with such\nmemory by leveraging a repository's commit history - a rich yet underutilized\nresource that chronicles the codebase's evolution. We introduce tools that\nallow the agent to retrieve from a non-parametric memory encompassing recent\nhistorical commits and linked issues, as well as functionality summaries of\nactively evolving parts of the codebase identified via commit patterns. We\ndemonstrate that augmenting such a memory can significantly improve LocAgent, a\nstate-of-the-art localization framework, on both SWE-bench-verified and the\nmore recent SWE-bench-live benchmarks. Our research contributes towards\ndeveloping agents that can accumulate and leverage past experience for\nlong-horizon tasks, more closely emulating the expertise of human developers."}
{"id": "2510.01024", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.01024", "abs": "https://arxiv.org/abs/2510.01024", "authors": ["Elvis Júnior", "Alan Valejo", "Jorge Valverde-Rebaza", "Vânia de Oliveira Neves"], "title": "GenIA-E2ETest: A Generative AI-Based Approach for End-to-End Test Automation", "comment": "Preprint of a paper published at the 39th Brazilian Symposium on\n  Software Engineering (SBES 2025). Please cite the published version:\n  https://sol.sbc.org.br/index.php/sbes/article/view/37006", "summary": "Software testing is essential to ensure system quality, but it remains\ntime-consuming and error-prone when performed manually. Although recent\nadvances in Large Language Models (LLMs) have enabled automated test\ngeneration, most existing solutions focus on unit testing and do not address\nthe challenges of end-to-end (E2E) testing, which validates complete\napplication workflows from user input to final system response. This paper\nintroduces GenIA-E2ETest, which leverages generative AI to generate executable\nE2E test scripts from natural language descriptions automatically. We evaluated\nthe approach on two web applications, assessing completeness, correctness,\nadaptation effort, and robustness. Results were encouraging: the scripts\nachieved an average of 77% for both element metrics, 82% for precision of\nexecution, 85% for execution recall, required minimal manual adjustments\n(average manual modification rate of 10%), and showed consistent performance in\ntypical web scenarios. Although some sensitivity to context-dependent\nnavigation and dynamic content was observed, the findings suggest that\nGenIA-E2ETest is a practical and effective solution to accelerate E2E test\nautomation from natural language, reducing manual effort and broadening access\nto automated testing."}
{"id": "2510.01077", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.01077", "abs": "https://arxiv.org/abs/2510.01077", "authors": ["Daniele Bifolco", "Guido Annicchiarico", "Pierluigi Barbiero", "Massimiliano Di Penta", "Fiorella Zampetti"], "title": "CodeGenLink: A Tool to Find the Likely Origin and License of Automatically Generated Code", "comment": "Proceedings of the 40th IEEE/ACM International Conference on\n  Automated Software Engineering (ASE 2025), November 16-20 2025, Seoul, South\n  Korea", "summary": "Large Language Models (LLMs) are widely used in software development tasks\nnowadays. Unlike reusing code taken from the Web, for LLMs' generated code,\ndevelopers are concerned about its lack of trustworthiness and possible\ncopyright or licensing violations, due to the lack of code provenance\ninformation. This paper proposes CodeGenLink, a GitHub CoPilot extension for\nVisual Studio Code aimed at (i) suggesting links containing code very similar\nto automatically generated code, and (ii) whenever possible, indicating the\nlicense of the likely origin of the code. CodeGenLink retrieves candidate links\nby combining LLMs with their web search features and then performs similarity\nanalysis between the generated and retrieved code. Preliminary results show\nthat CodeGenLink effectively filters unrelated links via similarity analysis\nand provides licensing information when available. Tool URL:\nhttps://github.com/danielebifolco/CodeGenLink Tool Video:\nhttps://youtu.be/M6nqjBf9_pw"}
{"id": "2510.01096", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.01096", "abs": "https://arxiv.org/abs/2510.01096", "authors": ["Nathan Wintersgill", "Trevor Stalnaker", "Daniel Otten", "Laura A. Heymann", "Oscar Chaparro", "Massimiliano Di Penta", "Daniel M. German", "Denys Poshyvanyk"], "title": "Developers' Perspectives on Software Licensing: Current Practices, Challenges, and Tools", "comment": null, "summary": "Most modern software products incorporate open-source components, requiring\ndevelopment teams to maintain compliance with each component's licenses.\nNoncompliance can lead to significant financial, legal, and reputational\nrepercussions. While some organizations may seek advice from legal\npractitioners to assist with licensing tasks, developers still play a key role\nin such a process. To this end, it is essential to understand how developers\napproach license compliance tasks, the challenges they encounter, and the tools\nthat they use. This work studies these aspects of software licensing practices\nthrough a study - conducted by a joint team of software engineering and legal\nresearchers - consisting of a survey with 58 software developers and seven\nfollow-up interviews. The study resulted in 15 key findings regarding the\ncurrent state of practice. We discuss the implications of our findings and\noffer directions for future research as well as actionable recommendations for\nlicensing tools."}
{"id": "2510.01182", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.01182", "abs": "https://arxiv.org/abs/2510.01182", "authors": ["Shuqing Li", "Chenran Zhang", "Binchang Li", "Cuiyun Gao", "Michael R. Lyu"], "title": "When Shared Worlds Break: Demystifying Defects in Multi-User Extended Reality Software Systems", "comment": null, "summary": "Multi-user Extended Reality (XR) systems enable transformative shared\nexperiences but introduce unique software defects that compromise user\nexperience. Understanding software defects in multi-user XR systems is crucial\nfor enhancing system reliability, yet remains underexplored. To fill the gap,\nthis paper presents the first large-scale empirical study of multi-user XR\ndefects, analyzing 2,649 real-world bug reports from diverse sources, including\ndeveloper forums, GitHub repositories, and app reviews on mainstream XR app\nstores. Through rigorous qualitative analysis using iterative open coding, we\ndevelop a comprehensive taxonomy that classifies multi-user XR bugs along three\ndimensions: Symptom Manifestation, Root Cause Origin, and Consequence Severity.\nOur findings reveal that synchronization inconsistencies and avatar-related\nanomalies are the most prevalent symptoms, while network/synchronization logic\ndefects and session management flaws emerge as dominant root causes.\nCritically, over 34% of analyzed bugs lead to severe consequences that\nfundamentally break the shared experience, including system crashes, persistent\ndisconnections, and complete interaction breakdowns, etc. We also identify\nconcerning privacy and health implications unique to multi-user XR contexts.\nBased on our findings of defect analysis, we provide actionable recommendations\nfor developers, platform vendors, and researchers. Our results demonstrate that\nmulti-user XR systems face distinct challenges at the intersection of\ndistributed systems, real-time 3D interaction, and immersive experiences,\nnecessitating specialized approaches to testing, debugging, and quality\nassurance."}
