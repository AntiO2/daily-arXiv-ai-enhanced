{"id": "2511.13907", "categories": ["cs.DB"], "pdf": "https://arxiv.org/pdf/2511.13907", "abs": "https://arxiv.org/abs/2511.13907", "authors": ["Sriom Chakrabarti", "Chuangtao Ma", "Arijit Khan", "Sebastian Link"], "title": "SQL-to-Text Generation with Weighted-AST Few-Shot Prompting", "comment": null, "summary": "SQL-to-Text generation aims at translating structured SQL queries into natural language descriptions, thereby facilitating comprehension of complex database operations for non-technical users. Although large language models (LLMs) have recently demonstrated promising results, current methods often fail to maintain the exact semantics of SQL queries, particularly when there are multiple possible correct phrasings. To address this problem, our work proposes Weighted-AST retrieval with prompting, an architecture that integrates structural query representations and LLM prompting. This method retrieves semantically relevant examples as few-shot prompts using a similarity metric based on an Abstract Syntax Tree (AST) with learned feature weights. Our structure-aware prompting technique ensures that generated descriptions are both fluent and faithful to the original query logic. Numerous experiments on three benchmark datasets - Spider, SParC, and CoSQL show that our method outperforms the current baselines by up to +17.24% in execution Accuracy (EX), performs superior in Exact Match (EM) and provides more consistent semantic fidelity when evaluated by humans, all while preserving competitive runtime performance. These results demonstrate that Weighted-AST prompting is a scalable and effective method for deriving natural language explanations from structured database queries.", "AI": {"tldr": "\u63d0\u51faWeighted-AST\u68c0\u7d22\u63d0\u793a\u65b9\u6cd5\uff0c\u901a\u8fc7\u57fa\u4e8e\u52a0\u6743\u62bd\u8c61\u8bed\u6cd5\u6811\u7684\u76f8\u4f3c\u5ea6\u68c0\u7d22\u76f8\u5173\u793a\u4f8b\u4f5c\u4e3afew-shot\u63d0\u793a\uff0c\u786e\u4fddSQL\u5230\u6587\u672c\u751f\u6210\u7684\u8bed\u4e49\u51c6\u786e\u6027\u548c\u6d41\u7545\u6027\u3002", "motivation": "\u89e3\u51b3\u73b0\u6709SQL-to-Text\u751f\u6210\u65b9\u6cd5\u5728\u4fdd\u6301SQL\u67e5\u8be2\u7cbe\u786e\u8bed\u4e49\u65b9\u9762\u7684\u4e0d\u8db3\uff0c\u7279\u522b\u662f\u5728\u5b58\u5728\u591a\u79cd\u6b63\u786e\u8868\u8ff0\u65f6\u8bed\u4e49\u4fdd\u771f\u5ea6\u4e0d\u591f\u7684\u95ee\u9898\u3002", "method": "\u63d0\u51faWeighted-AST\u68c0\u7d22\u63d0\u793a\u67b6\u6784\uff0c\u6574\u5408\u7ed3\u6784\u5316\u67e5\u8be2\u8868\u793a\u548cLLM\u63d0\u793a\uff0c\u4f7f\u7528\u57fa\u4e8e\u52a0\u6743AST\u7684\u76f8\u4f3c\u5ea6\u5ea6\u91cf\u68c0\u7d22\u8bed\u4e49\u76f8\u5173\u793a\u4f8b\u4f5c\u4e3afew-shot\u63d0\u793a\u3002", "result": "\u5728Spider\u3001SParC\u548cCoSQL\u4e09\u4e2a\u57fa\u51c6\u6570\u636e\u96c6\u4e0a\uff0c\u6267\u884c\u51c6\u786e\u7387\u63d0\u5347\u9ad8\u8fbe+17.24%\uff0c\u5728\u7cbe\u786e\u5339\u914d\u548c\u8bed\u4e49\u4fdd\u771f\u5ea6\u65b9\u9762\u8868\u73b0\u4f18\u5f02\uff0c\u540c\u65f6\u4fdd\u6301\u7ade\u4e89\u529b\u7684\u8fd0\u884c\u65f6\u6027\u80fd\u3002", "conclusion": "Weighted-AST\u63d0\u793a\u662f\u4e00\u79cd\u53ef\u6269\u5c55\u4e14\u6709\u6548\u7684\u65b9\u6cd5\uff0c\u80fd\u591f\u4ece\u7ed3\u6784\u5316\u6570\u636e\u5e93\u67e5\u8be2\u4e2d\u751f\u6210\u81ea\u7136\u8bed\u8a00\u89e3\u91ca\uff0c\u786e\u4fdd\u8bed\u4e49\u51c6\u786e\u6027\u548c\u6d41\u7545\u6027\u3002"}}
{"id": "2511.14067", "categories": ["cs.DB"], "pdf": "https://arxiv.org/pdf/2511.14067", "abs": "https://arxiv.org/abs/2511.14067", "authors": ["Zhiheng Cai", "Si Liu", "Hengfeng Wei", "Yuxing Chen", "Anqun Pan"], "title": "Fast Verification of Strong Database Isolation (Extended Version)", "comment": "18 pages, 19 figures, 3 tables; Accepted by VLDB'2026", "summary": "Strong isolation guarantees, such as serializability and snapshot isolation, are essential for maintaining data consistency and integrity in modern databases. Verifying whether a database upholds its claimed guarantees is increasingly critical, as these guarantees form a contract between the vendor and its users. However, this task is challenging, particularly in black-box settings, where only observable system behavior is available and often involves uncertain dependencies between transactions.\n  In this paper, we present VeriStrong, a fast verifier for strong database isolation. At its core is a novel formalism called hyper-polygraphs, which compactly captures both certain and uncertain transactional dependencies in database executions. Leveraging this formalism, we develop sound and complete encodings for verifying both serializability and snapshot isolation. To achieve high efficiency, VeriStrong tailors SMT solving to the characteristics of database workloads, in contrast to prior general-purpose approaches. Our extensive evaluation across diverse benchmarks shows that VeriStrong not only significantly outperforms state-of-the-art verifiers on the workloads they support, but also scales to large, general workloads beyond their reach, while maintaining high accuracy in detecting isolation anomalies.", "AI": {"tldr": "VeriStrong\u662f\u4e00\u4e2a\u7528\u4e8e\u9a8c\u8bc1\u6570\u636e\u5e93\u5f3a\u9694\u79bb\u4fdd\u8bc1\uff08\u5982\u53ef\u4e32\u884c\u5316\u548c\u5feb\u7167\u9694\u79bb\uff09\u7684\u9ad8\u6548\u9a8c\u8bc1\u5668\uff0c\u901a\u8fc7\u65b0\u9896\u7684\u8d85\u591a\u56fe\u5f62\u5f0f\u5316\u65b9\u6cd5\u5904\u7406\u4e8b\u52a1\u4f9d\u8d56\u5173\u7cfb\uff0c\u5e76\u9488\u5bf9\u6570\u636e\u5e93\u5de5\u4f5c\u8d1f\u8f7d\u7279\u6027\u4f18\u5316SMT\u6c42\u89e3\u3002", "motivation": "\u9a8c\u8bc1\u6570\u636e\u5e93\u662f\u5426\u9075\u5b88\u5176\u58f0\u79f0\u7684\u5f3a\u9694\u79bb\u4fdd\u8bc1\u81f3\u5173\u91cd\u8981\uff0c\u4f46\u5728\u9ed1\u76d2\u8bbe\u7f6e\u4e0b\u5177\u6709\u6311\u6218\u6027\uff0c\u56e0\u4e3a\u53ea\u80fd\u89c2\u5bdf\u7cfb\u7edf\u884c\u4e3a\u4e14\u5b58\u5728\u4e0d\u786e\u5b9a\u7684\u4e8b\u52a1\u4f9d\u8d56\u5173\u7cfb\u3002", "method": "\u63d0\u51fa\u8d85\u591a\u56fe\u5f62\u5f0f\u5316\u65b9\u6cd5\uff0c\u7d27\u51d1\u5730\u6355\u6349\u6570\u636e\u5e93\u6267\u884c\u4e2d\u7684\u786e\u5b9a\u548c\u4e0d\u786e\u5b9a\u4e8b\u52a1\u4f9d\u8d56\uff1b\u5f00\u53d1\u53ef\u9a8c\u8bc1\u53ef\u4e32\u884c\u5316\u548c\u5feb\u7167\u9694\u79bb\u7684\u5b8c\u5907\u7f16\u7801\uff1b\u9488\u5bf9\u6570\u636e\u5e93\u5de5\u4f5c\u8d1f\u8f7d\u7279\u6027\u5b9a\u5236SMT\u6c42\u89e3\u3002", "result": "\u5728\u591a\u6837\u5316\u57fa\u51c6\u6d4b\u8bd5\u4e2d\uff0cVeriStrong\u4e0d\u4ec5\u663e\u8457\u4f18\u4e8e\u73b0\u6709\u6700\u5148\u8fdb\u9a8c\u8bc1\u5668\uff0c\u8fd8\u80fd\u6269\u5c55\u5230\u5927\u578b\u901a\u7528\u5de5\u4f5c\u8d1f\u8f7d\uff0c\u540c\u65f6\u4fdd\u6301\u9ad8\u7cbe\u5ea6\u7684\u9694\u79bb\u5f02\u5e38\u68c0\u6d4b\u80fd\u529b\u3002", "conclusion": "VeriStrong\u901a\u8fc7\u65b0\u9896\u7684\u5f62\u5f0f\u5316\u65b9\u6cd5\u548c\u9488\u5bf9\u6027\u7684\u4f18\u5316\uff0c\u5b9e\u73b0\u4e86\u5bf9\u6570\u636e\u5e93\u5f3a\u9694\u79bb\u4fdd\u8bc1\u7684\u9ad8\u6548\u3001\u53ef\u6269\u5c55\u9a8c\u8bc1\u3002"}}
{"id": "2511.14162", "categories": ["cs.DB"], "pdf": "https://arxiv.org/pdf/2511.14162", "abs": "https://arxiv.org/abs/2511.14162", "authors": ["Supawit Chockchowwat", "Sumay Thakurdesai", "Zhaoheng Li", "Matthew Krafczyk", "Yongjoo Park"], "title": "Chipmink: Efficient Delta Identification for Massive Object Graph", "comment": "17 pages, 21 figures, to appear at VLDB 2026", "summary": "Ranging from batch scripts to computational notebooks, modern data science tools rely on massive and evolving object graphs that represent structured data, models, plots, and more. Persisting these objects is critical, not only to enhance system robustness against unexpected failures but also to support continuous, non-linear data exploration via versioning. Existing object persistence mechanisms (e.g., Pickle, Dill) rely on complete snapshotting, often redundantly storing unchanged objects during execution and exploration, resulting in significant inefficiency in both time and storage. Unlike DBMSs, data science systems lack centralized buffer managers that track dirty objects. Worse, object states span various locations such as memory heaps, shared memory, GPUs, and remote machines, making dirty object identification fundamentally more challenging. In this work, we propose a graph-based object store, named Chipmink, that acts like the centralized buffer manager. Unlike static pages in DBMSs, persistence units in Chipmink are dynamically induced by partitioning objects into appropriate subgroups (called pods), minimizing expected persistence costs based on object sizes and reference structure. These pods effectively isolate dirty objects, enabling efficient partial persistence. Our experiments show that Chipmink is general, supporting libraries that rely on shared memory, GPUs, and remote objects. Moreover, Chipmink achieves up to 36.5x smaller storage sizes and 12.4x faster persistence than the best baselines in real-world notebooks and scripts.", "AI": {"tldr": "Chipmink\u662f\u4e00\u4e2a\u57fa\u4e8e\u56fe\u7684\u5bf9\u8c61\u5b58\u50a8\u7cfb\u7edf\uff0c\u901a\u8fc7\u52a8\u6001\u5206\u533a\u5bf9\u8c61\u5230pod\u4e2d\u6765\u8bc6\u522b\u810f\u5bf9\u8c61\uff0c\u5b9e\u73b0\u9ad8\u6548\u7684\u90e8\u5206\u6301\u4e45\u5316\uff0c\u76f8\u6bd4\u73b0\u6709\u65b9\u6cd5\u663e\u8457\u51cf\u5c11\u5b58\u50a8\u7a7a\u95f4\u548c\u63d0\u5347\u6301\u4e45\u5316\u901f\u5ea6\u3002", "motivation": "\u73b0\u4ee3\u6570\u636e\u79d1\u5b66\u5de5\u5177\u4e2d\u7684\u5bf9\u8c61\u6301\u4e45\u5316\u673a\u5236\uff08\u5982Pickle\u3001Dill\uff09\u4f9d\u8d56\u5b8c\u6574\u5feb\u7167\uff0c\u4f1a\u5197\u4f59\u5b58\u50a8\u672a\u66f4\u6539\u5bf9\u8c61\uff0c\u5bfc\u81f4\u65f6\u95f4\u548c\u5b58\u50a8\u6548\u7387\u4f4e\u4e0b\u3002\u6570\u636e\u79d1\u5b66\u7cfb\u7edf\u7f3a\u4e4f\u7c7b\u4f3cDBMS\u7684\u96c6\u4e2d\u5f0f\u7f13\u51b2\u533a\u7ba1\u7406\u5668\u6765\u8ddf\u8e2a\u810f\u5bf9\u8c61\u3002", "method": "\u63d0\u51fa\u57fa\u4e8e\u56fe\u7684\u5bf9\u8c61\u5b58\u50a8Chipmink\uff0c\u901a\u8fc7\u52a8\u6001\u5c06\u5bf9\u8c61\u5206\u533a\u5230\u9002\u5f53\u7684\u5b50\u7ec4\uff08\u79f0\u4e3apod\uff09\u6765\u6700\u5c0f\u5316\u9884\u671f\u6301\u4e45\u5316\u6210\u672c\uff0c\u8fd9\u4e9bpod\u6709\u6548\u9694\u79bb\u810f\u5bf9\u8c61\uff0c\u5b9e\u73b0\u9ad8\u6548\u7684\u90e8\u5206\u6301\u4e45\u5316\u3002", "result": "Chipmink\u652f\u6301\u4f9d\u8d56\u5171\u4eab\u5185\u5b58\u3001GPU\u548c\u8fdc\u7a0b\u5bf9\u8c61\u7684\u5e93\uff0c\u5728\u771f\u5b9e\u7b14\u8bb0\u672c\u548c\u811a\u672c\u4e2d\u6bd4\u6700\u4f73\u57fa\u7ebf\u65b9\u6cd5\u5b9e\u73b0\u9ad8\u8fbe36.5\u500d\u7684\u5b58\u50a8\u7a7a\u95f4\u51cf\u5c11\u548c12.4\u500d\u7684\u6301\u4e45\u5316\u901f\u5ea6\u63d0\u5347\u3002", "conclusion": "Chipmink\u4f5c\u4e3a\u96c6\u4e2d\u5f0f\u7f13\u51b2\u533a\u7ba1\u7406\u5668\uff0c\u901a\u8fc7\u52a8\u6001\u5bf9\u8c61\u5206\u533a\u548c\u810f\u5bf9\u8c61\u9694\u79bb\uff0c\u4e3a\u6570\u636e\u79d1\u5b66\u7cfb\u7edf\u63d0\u4f9b\u4e86\u9ad8\u6548\u7684\u6301\u4e45\u5316\u89e3\u51b3\u65b9\u6848\u3002"}}
{"id": "2511.14482", "categories": ["cs.DB", "cs.LG"], "pdf": "https://arxiv.org/pdf/2511.14482", "abs": "https://arxiv.org/abs/2511.14482", "authors": ["Tim Schwabe", "Maribel Acosta"], "title": "Gradient-Based Join Ordering", "comment": null, "summary": "Join ordering is the NP-hard problem of selecting the most efficient sequence in which to evaluate joins (conjunctive, binary operators) in a database query. As the performance of query execution critically depends on this choice, join ordering lies at the core of query optimization. Traditional approaches cast this problem as a discrete combinatorial search over binary trees guided by a cost model, but they often suffer from high computational complexity and limited scalability. We show that, when the cost model is differentiable, the query plans can be continuously relaxed into a soft adjacency matrix representing a superposition of plans. This continuous relaxation, together with a Gumbel-Softmax parameterization of the adjacency matrix and differentiable constraints enforcing plan validity, enables gradient-based search for plans within this relaxed space. Using a learned Graph Neural Network as the cost model, we demonstrate that this gradient-based approach can find comparable and even lower-cost plans compared to traditional discrete local search methods on two different graph datasets. Furthermore, we empirically show that the runtime of this approach scales linearly with query size, in contrast to quadratic or exponential runtimes of classical approaches. We believe this first step towards gradient-based join ordering can lead to more effective and efficient query optimizers in the future.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u57fa\u4e8e\u68af\u5ea6\u7684\u8fde\u63a5\u6392\u5e8f\u65b9\u6cd5\uff0c\u901a\u8fc7\u8fde\u7eed\u677e\u5f1b\u5c06\u67e5\u8be2\u8ba1\u5212\u8868\u793a\u4e3a\u8f6f\u90bb\u63a5\u77e9\u9635\uff0c\u7ed3\u5408Gumbel-Softmax\u53c2\u6570\u5316\u548c\u53ef\u5fae\u7ea6\u675f\uff0c\u4f7f\u7528\u56fe\u795e\u7ecf\u7f51\u7edc\u4f5c\u4e3a\u6210\u672c\u6a21\u578b\u8fdb\u884c\u68af\u5ea6\u641c\u7d22\u3002", "motivation": "\u4f20\u7edf\u8fde\u63a5\u6392\u5e8f\u65b9\u6cd5\u4f5c\u4e3a\u79bb\u6563\u7ec4\u5408\u641c\u7d22\u95ee\u9898\u5b58\u5728\u8ba1\u7b97\u590d\u6742\u5ea6\u9ad8\u548c\u53ef\u6269\u5c55\u6027\u6709\u9650\u7684\u95ee\u9898\uff0c\u9700\u8981\u66f4\u9ad8\u6548\u7684\u89e3\u51b3\u65b9\u6848\u3002", "method": "\u5c06\u67e5\u8be2\u8ba1\u5212\u8fde\u7eed\u677e\u5f1b\u4e3a\u8f6f\u90bb\u63a5\u77e9\u9635\uff0c\u4f7f\u7528Gumbel-Softmax\u53c2\u6570\u5316\u548c\u53ef\u5fae\u7ea6\u675f\u786e\u4fdd\u8ba1\u5212\u6709\u6548\u6027\uff0c\u7ed3\u5408\u56fe\u795e\u7ecf\u7f51\u7edc\u6210\u672c\u6a21\u578b\u8fdb\u884c\u68af\u5ea6\u641c\u7d22\u3002", "result": "\u5728\u4e24\u4e2a\u56fe\u6570\u636e\u96c6\u4e0a\uff0c\u8be5\u65b9\u6cd5\u80fd\u627e\u5230\u4e0e\u4f20\u7edf\u79bb\u6563\u5c40\u90e8\u641c\u7d22\u65b9\u6cd5\u76f8\u5f53\u751a\u81f3\u66f4\u4f4e\u6210\u672c\u7684\u8ba1\u5212\uff0c\u4e14\u8fd0\u884c\u65f6\u95f4\u968f\u67e5\u8be2\u5927\u5c0f\u7ebf\u6027\u589e\u957f\u3002", "conclusion": "\u8fd9\u662f\u8fc8\u5411\u57fa\u4e8e\u68af\u5ea6\u7684\u8fde\u63a5\u6392\u5e8f\u7684\u7b2c\u4e00\u6b65\uff0c\u6709\u671b\u5728\u672a\u6765\u5b9e\u73b0\u66f4\u6709\u6548\u548c\u9ad8\u6548\u7684\u67e5\u8be2\u4f18\u5316\u5668\u3002"}}
{"id": "2511.13972", "categories": ["cs.SE", "cs.CL"], "pdf": "https://arxiv.org/pdf/2511.13972", "abs": "https://arxiv.org/abs/2511.13972", "authors": ["Jeremiah Bohr"], "title": "Show and Tell: Prompt Strategies for Style Control in Multi-Turn LLM Code Generation", "comment": "23 pages, 2 figures, 3 tables. Under review", "summary": "Language models generate functionally correct code that tends toward excessive verbosity, with elaborate documentation and defensive patterns that diverge from human baselines. Two prompting mechanisms have emerged for stylistic control: instruction based prompts that articulate abstract directives, and example based prompts that provide concrete code demonstrations. The core problem is whether stylistic constraints persist when models enhance initial implementations with additional features while maintaining high functional accuracy. Here we show that instruction-based, example-based, and combined prompts produce distinct patterns of initial control and expansion discipline over one enhancement turn. We manipulated system prompts across four conditions in a paired two-turn protocol where models first generated solutions to an intermediate Python task, then revised their code under general improvement directives, holding the user task fixed (N = 160 paired programs). Combined prompts produced the strongest initial compression and greatest expansion discipline. Instructions showed large initial effects and moderate expansion discipline. Examples showed modest initial effects with no expansion discipline. These results show that initial prompt effectiveness and expansion discipline are separate aspects of prompt design, and that combined approaches provide the most stable stylistic control in this two-turn workflow.", "AI": {"tldr": "\u8be5\u7814\u7a76\u6bd4\u8f83\u4e86\u6307\u4ee4\u63d0\u793a\u3001\u793a\u4f8b\u63d0\u793a\u548c\u7ec4\u5408\u63d0\u793a\u5728\u63a7\u5236\u8bed\u8a00\u6a21\u578b\u4ee3\u7801\u751f\u6210\u98ce\u683c\u65b9\u9762\u7684\u6548\u679c\uff0c\u53d1\u73b0\u5728\u4e24\u8f6e\u534f\u8bae\u4e2d\uff0c\u7ec4\u5408\u63d0\u793a\u5728\u521d\u59cb\u538b\u7f29\u548c\u6269\u5c55\u7eaa\u5f8b\u65b9\u9762\u8868\u73b0\u6700\u4f73\u3002", "motivation": "\u8bed\u8a00\u6a21\u578b\u751f\u6210\u7684\u4ee3\u7801\u5f80\u5f80\u8fc7\u4e8e\u5197\u957f\uff0c\u4e0e\u4eba\u7c7b\u57fa\u51c6\u5b58\u5728\u5dee\u5f02\u3002\u7814\u7a76\u65e8\u5728\u63a2\u7d22\u4e0d\u540c\u63d0\u793a\u673a\u5236\u5728\u4fdd\u6301\u529f\u80fd\u51c6\u786e\u6027\u7684\u540c\u65f6\uff0c\u80fd\u5426\u7ef4\u6301\u98ce\u683c\u7ea6\u675f\u3002", "method": "\u91c7\u7528\u914d\u5bf9\u4e24\u8f6e\u534f\u8bae\uff0c\u5728\u56db\u79cd\u63d0\u793a\u6761\u4ef6\u4e0b\u8ba9\u6a21\u578b\u9996\u5148\u751f\u6210Python\u4efb\u52a1\u89e3\u51b3\u65b9\u6848\uff0c\u7136\u540e\u5728\u901a\u7528\u6539\u8fdb\u6307\u4ee4\u4e0b\u4fee\u8ba2\u4ee3\u7801\uff0c\u4fdd\u6301\u7528\u6237\u4efb\u52a1\u4e0d\u53d8\uff08N=160\u5bf9\u7a0b\u5e8f\uff09\u3002", "result": "\u7ec4\u5408\u63d0\u793a\u4ea7\u751f\u6700\u5f3a\u7684\u521d\u59cb\u538b\u7f29\u548c\u6700\u5927\u7684\u6269\u5c55\u7eaa\u5f8b\uff1b\u6307\u4ee4\u63d0\u793a\u663e\u793a\u5927\u7684\u521d\u59cb\u6548\u679c\u548c\u4e2d\u7b49\u6269\u5c55\u7eaa\u5f8b\uff1b\u793a\u4f8b\u63d0\u793a\u663e\u793a\u9002\u5ea6\u7684\u521d\u59cb\u6548\u679c\u4f46\u65e0\u6269\u5c55\u7eaa\u5f8b\u3002", "conclusion": "\u521d\u59cb\u63d0\u793a\u6709\u6548\u6027\u548c\u6269\u5c55\u7eaa\u5f8b\u662f\u63d0\u793a\u8bbe\u8ba1\u7684\u4e24\u4e2a\u72ec\u7acb\u65b9\u9762\uff0c\u7ec4\u5408\u65b9\u6cd5\u5728\u4e24\u8f6e\u5de5\u4f5c\u6d41\u7a0b\u4e2d\u63d0\u4f9b\u6700\u7a33\u5b9a\u7684\u98ce\u683c\u63a7\u5236\u3002"}}
{"id": "2511.13727", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2511.13727", "abs": "https://arxiv.org/abs/2511.13727", "authors": ["Sophie Wenning"], "title": "Boosting performance: Gradient Clock Synchronisation with two-way measured links", "comment": "Master's thesis", "summary": "This master thesis extends the formal model of the GCS algorithm as presented by (Fan and Lynch 2004, 325), (Lenzen, Locher and Wattenhofer 2008, 510) and (F\u00fcgger et al. 2023) to operate under implementation-near assumptions by replacing the one-way measurement paradigm assumed in prior work by the two-way measurement paradigm. With this change of paradigm, we remove many restrictions previously enforced to allow provable performance. Most notability, while maintaining the core behaviour of GCS, we: 1. Lift the requirement for unitary link lengths and thereby create a realistic model for flexible deployment of implementations of GCS in practice. 2. Provide a formal model of frequency sources assumed in prior work. 3. Perform a fine grained distinction between the different components of the algorithm's estimation error and globally reduce its impact by multiple orders of magnitude. 4. Significantly reduce the contribution of the uncertainty to the algorithm's estimation error to be in the range of 10\\% to 0,1\\% of the delay per link instead of being in the oder of the delay per link as in prior work and show matching upper bounds on the local and global skew of GCS.", "AI": {"tldr": "\u8be5\u8bba\u6587\u6269\u5c55\u4e86GCS\u7b97\u6cd5\u7684\u5f62\u5f0f\u5316\u6a21\u578b\uff0c\u901a\u8fc7\u5c06\u5355\u5411\u6d4b\u91cf\u8303\u5f0f\u6539\u4e3a\u53cc\u5411\u6d4b\u91cf\u8303\u5f0f\uff0c\u5728\u5b9e\u73b0\u63a5\u8fd1\u7684\u5047\u8bbe\u4e0b\u8fd0\u884c\uff0c\u79fb\u9664\u4e86\u8bb8\u591a\u5148\u524d\u4e3a\u8bc1\u660e\u6027\u80fd\u800c\u65bd\u52a0\u7684\u9650\u5236\u3002", "motivation": "\u6269\u5c55GCS\u7b97\u6cd5\u7684\u5f62\u5f0f\u5316\u6a21\u578b\uff0c\u4f7f\u5176\u5728\u5b9e\u73b0\u63a5\u8fd1\u7684\u5047\u8bbe\u4e0b\u8fd0\u884c\uff0c\u79fb\u9664\u5148\u524d\u4e3a\u8bc1\u660e\u6027\u80fd\u800c\u65bd\u52a0\u7684\u9650\u5236\uff0c\u521b\u5efa\u66f4\u73b0\u5b9e\u7684\u90e8\u7f72\u6a21\u578b\u3002", "method": "\u5c06\u5355\u5411\u6d4b\u91cf\u8303\u5f0f\u66ff\u6362\u4e3a\u53cc\u5411\u6d4b\u91cf\u8303\u5f0f\uff0c\u653e\u5bbd\u5355\u4f4d\u94fe\u8def\u957f\u5ea6\u8981\u6c42\uff0c\u63d0\u4f9b\u9891\u7387\u6e90\u7684\u5f62\u5f0f\u5316\u6a21\u578b\uff0c\u5bf9\u7b97\u6cd5\u4f30\u8ba1\u8bef\u5dee\u7684\u4e0d\u540c\u7ec4\u6210\u90e8\u5206\u8fdb\u884c\u7ec6\u7c92\u5ea6\u533a\u5206\u3002", "result": "\u5c06\u4e0d\u786e\u5b9a\u6027\u5bf9\u7b97\u6cd5\u4f30\u8ba1\u8bef\u5dee\u7684\u8d21\u732e\u4ece\u5ef6\u8fdf\u91cf\u7ea7\u663e\u8457\u964d\u4f4e\u5230\u6bcf\u4e2a\u94fe\u8def\u5ef6\u8fdf\u768410%\u52300.1%\uff0c\u5e76\u7ed9\u51fa\u4e86GCS\u5c40\u90e8\u548c\u5168\u5c40\u504f\u5dee\u7684\u5339\u914d\u4e0a\u754c\u3002", "conclusion": "\u901a\u8fc7\u6539\u53d8\u6d4b\u91cf\u8303\u5f0f\uff0c\u5728\u4fdd\u6301GCS\u6838\u5fc3\u884c\u4e3a\u7684\u540c\u65f6\uff0c\u663e\u8457\u63d0\u9ad8\u4e86\u7b97\u6cd5\u7684\u5b9e\u7528\u6027\u548c\u6027\u80fd\uff0c\u4e3a\u5b9e\u9645\u90e8\u7f72\u63d0\u4f9b\u4e86\u66f4\u73b0\u5b9e\u7684\u6a21\u578b\u3002"}}
{"id": "2511.14502", "categories": ["cs.DB", "cs.DC"], "pdf": "https://arxiv.org/pdf/2511.14502", "abs": "https://arxiv.org/abs/2511.14502", "authors": ["Sviatoslav Stumpf", "Vladislav Povyshev"], "title": "Overview and Prospects of Using Integer Surrogate Keys for Data Warehouse Performance Optimization", "comment": null, "summary": "The aim of this paper is to examine and demonstrate how integer-based datetime labels (integer surrogate keys for time) can optimize data-warehouse and time-series performance, proposing practical formats and algorithms and validating their efficiency on real-world workloads. It is shown that replacing standard DATE and TIMESTAMP types with 32- and 64-bit integer formats reduces storage requirements by 30-60 percent and speeds up query execution by 25-40 percent. The paper presents indexing, aggregation, compression, and batching algorithms demonstrating up to an eightfold increase in throughput. Practical examples from finance, telecommunications, IoT, and scientific research confirm the efficiency and versatility of the proposed approach.", "AI": {"tldr": "\u4f7f\u7528\u6574\u6570\u578b\u65e5\u671f\u65f6\u95f4\u6807\u7b7e\u66ff\u4ee3\u6807\u51c6DATE\u548cTIMESTAMP\u7c7b\u578b\uff0c\u53ef\u51cf\u5c11\u5b58\u50a830-60%\uff0c\u63d0\u5347\u67e5\u8be2\u6027\u80fd25-40%\uff0c\u541e\u5410\u91cf\u6700\u9ad8\u63d0\u53478\u500d", "motivation": "\u4f18\u5316\u6570\u636e\u4ed3\u5e93\u548c\u65f6\u95f4\u5e8f\u5217\u6027\u80fd\uff0c\u89e3\u51b3\u6807\u51c6\u65e5\u671f\u65f6\u95f4\u7c7b\u578b\u5b58\u50a8\u6548\u7387\u4f4e\u3001\u67e5\u8be2\u6027\u80fd\u5dee\u7684\u95ee\u9898", "method": "\u63d0\u51fa32\u4f4d\u548c64\u4f4d\u6574\u6570\u683c\u5f0f\uff0c\u5f00\u53d1\u7d22\u5f15\u3001\u805a\u5408\u3001\u538b\u7f29\u548c\u6279\u5904\u7406\u7b97\u6cd5", "result": "\u5b58\u50a8\u9700\u6c42\u51cf\u5c1130-60%\uff0c\u67e5\u8be2\u6267\u884c\u901f\u5ea6\u63d0\u534725-40%\uff0c\u541e\u5410\u91cf\u6700\u9ad8\u63d0\u53478\u500d", "conclusion": "\u6574\u6570\u578b\u65e5\u671f\u65f6\u95f4\u6807\u7b7e\u5728\u91d1\u878d\u3001\u7535\u4fe1\u3001\u7269\u8054\u7f51\u548c\u79d1\u5b66\u7814\u7a76\u7b49\u5b9e\u9645\u5e94\u7528\u4e2d\u8868\u73b0\u51fa\u9ad8\u6548\u6027\u548c\u901a\u7528\u6027"}}
{"id": "2511.13996", "categories": ["cs.SE", "cs.HC"], "pdf": "https://arxiv.org/pdf/2511.13996", "abs": "https://arxiv.org/abs/2511.13996", "authors": ["Daihan Xu", "Diana Martin"], "title": "Exploring the Use of ChatGPT by Computer Science Students in Software Development: Applications, Ethical Considerations, and Insights for Engineering Education", "comment": "Full paper oral presentation at the European Society for Engineering Education (SEFI) 2025 Annual Conference (September 2025)", "summary": "ChatGPT has been increasingly used in computer science, offering efficient support across software development tasks. While it helps students navigate programming challenges, its use also raises concerns about academic integrity and overreliance. Despite growing interest in this topic, prior research has largely relied on surveys, emphasizing trends over in-depth analysis of students' strategies and ethical awareness. This study complements existing work through a qualitative investigation of how computer science students in one UK institution strategically and ethically engage with ChatGPT in software development projects. Drawing on semi-structured interviews, it explores two key questions: How do computer science students ethically and strategically report using ChatGPT in software development projects? How do students understand and perceive the ethical issues associated with using ChatGPT in academic and professional contexts? Findings reveal a shift in students' learning models, moving from traditional \"independent thinking-manual coding-iterative debugging\" to \"AI-assisted ideation-interactive programming-collaborative optimization.\" Importantly, many use ChatGPT conversationally to deepen understanding, while consciously reserving creative and high-level decision-making tasks for themselves. Students tend to cap ChatGPT's contribution to roughly 30%, and evaluate its output to mitigate overreliance. However, only a minority thoroughly analyze AI-generated code, raising concerns about reduced critical engagement. Meanwhile, students reject uncredited use, highlight risks such as privacy breaches and skill degradation, and call for clear usage guidelines set by their teachers. This research offers novel insights into the evolving learner-AI dynamic and highlights the need for explicit guidance to support responsible and pedagogically sound use of such tools.", "AI": {"tldr": "\u8be5\u7814\u7a76\u901a\u8fc7\u5b9a\u6027\u8bbf\u8c08\u63a2\u8ba8\u8ba1\u7b97\u673a\u79d1\u5b66\u5b66\u751f\u5982\u4f55\u5728\u8f6f\u4ef6\u5f00\u53d1\u9879\u76ee\u4e2d\u7b56\u7565\u6027\u548c\u9053\u5fb7\u5730\u4f7f\u7528ChatGPT\uff0c\u63ed\u793a\u4e86\u5b66\u751f\u5b66\u4e60\u6a21\u5f0f\u4ece\u4f20\u7edf\u8f6c\u5411AI\u8f85\u52a9\u7684\u8f6c\u53d8\uff0c\u4ee5\u53ca\u5b66\u751f\u5bf9AI\u4f7f\u7528\u4f26\u7406\u95ee\u9898\u7684\u8ba4\u77e5\u3002", "motivation": "ChatGPT\u5728\u8ba1\u7b97\u673a\u79d1\u5b66\u6559\u80b2\u4e2d\u7684\u4f7f\u7528\u65e5\u76ca\u589e\u591a\uff0c\u4f46\u73b0\u6709\u7814\u7a76\u591a\u4f9d\u8d56\u8c03\u67e5\u95ee\u5377\uff0c\u7f3a\u4e4f\u5bf9\u5b66\u751f\u4f7f\u7528\u7b56\u7565\u548c\u4f26\u7406\u610f\u8bc6\u7684\u6df1\u5165\u5206\u6790\u3002\u672c\u7814\u7a76\u65e8\u5728\u901a\u8fc7\u5b9a\u6027\u7814\u7a76\u586b\u8865\u8fd9\u4e00\u7a7a\u767d\u3002", "method": "\u91c7\u7528\u534a\u7ed3\u6784\u5316\u8bbf\u8c08\u65b9\u6cd5\uff0c\u5bf9\u82f1\u56fd\u4e00\u6240\u9662\u6821\u7684\u8ba1\u7b97\u673a\u79d1\u5b66\u5b66\u751f\u8fdb\u884c\u5b9a\u6027\u8c03\u67e5\uff0c\u5206\u6790\u4ed6\u4eec\u5728\u8f6f\u4ef6\u5f00\u53d1\u9879\u76ee\u4e2d\u4f7f\u7528ChatGPT\u7684\u7b56\u7565\u548c\u4f26\u7406\u8003\u91cf\u3002", "result": "\u7814\u7a76\u53d1\u73b0\u5b66\u751f\u7684\u5b66\u4e60\u6a21\u5f0f\u4ece\u4f20\u7edf\u7684\"\u72ec\u7acb\u601d\u8003-\u624b\u52a8\u7f16\u7801-\u8fed\u4ee3\u8c03\u8bd5\"\u8f6c\u53d8\u4e3a\"AI\u8f85\u52a9\u6784\u601d-\u4ea4\u4e92\u5f0f\u7f16\u7a0b-\u534f\u4f5c\u4f18\u5316\"\u3002\u5b66\u751f\u503e\u5411\u4e8e\u5c06ChatGPT\u7684\u8d21\u732e\u63a7\u5236\u572830%\u5de6\u53f3\uff0c\u5e76\u8bc4\u4f30\u5176\u8f93\u51fa\u4ee5\u907f\u514d\u8fc7\u5ea6\u4f9d\u8d56\uff0c\u4f46\u53ea\u6709\u5c11\u6570\u4eba\u4f1a\u6df1\u5165\u5206\u6790AI\u751f\u6210\u7684\u4ee3\u7801\u3002", "conclusion": "\u5b66\u751f\u62d2\u7edd\u672a\u7ecf\u6388\u6743\u7684\u4f7f\u7528\uff0c\u5f3a\u8c03\u9690\u79c1\u6cc4\u9732\u548c\u6280\u80fd\u9000\u5316\u7b49\u98ce\u9669\uff0c\u5e76\u547c\u5401\u6559\u5e08\u5236\u5b9a\u660e\u786e\u7684\u4f7f\u7528\u6307\u5357\u3002\u7814\u7a76\u5f3a\u8c03\u4e86\u4e3a\u652f\u6301\u8d1f\u8d23\u4efb\u548c\u6559\u5b66\u5408\u7406\u4f7f\u7528\u6b64\u7c7b\u5de5\u5177\u63d0\u4f9b\u660e\u786e\u6307\u5bfc\u7684\u5fc5\u8981\u6027\u3002"}}
{"id": "2511.13728", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2511.13728", "abs": "https://arxiv.org/abs/2511.13728", "authors": ["Maximilian Reisecker", "Cynthia Marcelino", "Thomas Pusztai", "Stefan Nastic"], "title": "Gaia: Hybrid Hardware Acceleration for Serverless AI in the 3D Compute Continuum", "comment": "In IEEE ACM 12th International Conference on Big Data Computing, Applications and Technologies (BDCAT 25), 2025, Nantes, France", "summary": "Serverless computing offers elastic scaling and pay-per-use execution, making it well-suited for AI workloads. As these workloads run in heterogeneous environments such as the Edge-Cloud-Space 3D Continuum, they often require intensive parallel computation, which GPUs can perform far more efficiently than CPUs. However, current platforms struggle to manage hardware acceleration effectively, as static user-device assignments fail to ensure SLO compliance under varying loads or placements, and one-time dynamic selections often lead to suboptimal or cost-inefficient configurations. To address these issues, we present Gaia, a GPU-as-a-service model and architecture that makes hardware acceleration a platform concern. Gaia combines (i) a lightweight Execution Mode Identifier that inspects function code at deploy time to emit one of four execution modes, and a Dynamic Function Runtime that continuously reevaluates user-defined SLOs to promote or demote between CPU- and GPU backends. Our evaluation shows that it seamlessly selects the best hardware acceleration for the workload, reducing end-to-end latency by up to 95%. These results indicate that Gaia enables SLO-aware, cost-efficient acceleration for serverless AI across heterogeneous environments.", "AI": {"tldr": "Gaia\u662f\u4e00\u4e2aGPU\u5373\u670d\u52a1\u6a21\u578b\u548c\u67b6\u6784\uff0c\u901a\u8fc7\u52a8\u6001\u6267\u884c\u6a21\u5f0f\u8bc6\u522b\u548c\u8fd0\u884c\u65f6\u8bc4\u4f30\uff0c\u4e3a\u5f02\u6784\u73af\u5883\u4e2d\u7684\u65e0\u670d\u52a1\u5668AI\u5de5\u4f5c\u8d1f\u8f7d\u63d0\u4f9bSLO\u611f\u77e5\u3001\u6210\u672c\u9ad8\u6548\u7684\u786c\u4ef6\u52a0\u901f\u3002", "motivation": "\u5f53\u524d\u5e73\u53f0\u5728\u7ba1\u7406\u786c\u4ef6\u52a0\u901f\u65b9\u9762\u5b58\u5728\u56f0\u96be\uff0c\u9759\u6001\u7528\u6237-\u8bbe\u5907\u5206\u914d\u65e0\u6cd5\u5728\u53d8\u5316\u8d1f\u8f7d\u6216\u653e\u7f6e\u4e0b\u786e\u4fddSLO\u5408\u89c4\uff0c\u4e00\u6b21\u6027\u52a8\u6001\u9009\u62e9\u5f80\u5f80\u5bfc\u81f4\u6b21\u4f18\u6216\u6210\u672c\u4f4e\u6548\u7684\u914d\u7f6e\u3002", "method": "Gaia\u7ed3\u5408\u4e86\u8f7b\u91cf\u7ea7\u6267\u884c\u6a21\u5f0f\u6807\u8bc6\u5668\uff08\u5728\u90e8\u7f72\u65f6\u68c0\u67e5\u51fd\u6570\u4ee3\u7801\u5e76\u53d1\u51fa\u56db\u79cd\u6267\u884c\u6a21\u5f0f\u4e4b\u4e00\uff09\u548c\u52a8\u6001\u51fd\u6570\u8fd0\u884c\u65f6\uff08\u6301\u7eed\u91cd\u65b0\u8bc4\u4f30\u7528\u6237\u5b9a\u4e49\u7684SLO\u4ee5\u5728CPU\u548cGPU\u540e\u7aef\u4e4b\u95f4\u8fdb\u884c\u5347\u7ea7\u6216\u964d\u7ea7\uff09\u3002", "result": "\u8bc4\u4f30\u663e\u793aGaia\u80fd\u591f\u65e0\u7f1d\u9009\u62e9\u6700\u9002\u5408\u5de5\u4f5c\u8d1f\u8f7d\u7684\u786c\u4ef6\u52a0\u901f\uff0c\u5c06\u7aef\u5230\u7aef\u5ef6\u8fdf\u964d\u4f4e\u9ad8\u8fbe95%\u3002", "conclusion": "Gaia\u80fd\u591f\u5728\u5f02\u6784\u73af\u5883\u4e2d\u4e3a\u65e0\u670d\u52a1\u5668AI\u5b9e\u73b0SLO\u611f\u77e5\u3001\u6210\u672c\u9ad8\u6548\u7684\u52a0\u901f\u3002"}}
{"id": "2511.14629", "categories": ["cs.DB"], "pdf": "https://arxiv.org/pdf/2511.14629", "abs": "https://arxiv.org/abs/2511.14629", "authors": ["Anadi Shakya", "Primal Pappachan", "David Maier", "Roberto Yus", "Sharad Mehrotra", "Johann-Christoph Freytag"], "title": "Scalable Enforcement of Fine Grained Access Control Policies in Relational Database Management Systems", "comment": null, "summary": "The proliferation of smart technologies and evolving privacy regulations such as the GDPR and CPRA has increased the need to manage fine-grained access control (FGAC) policies in database management systems (DBMSs). Existing approaches to enforcing FGAC policies do not scale to thousands of policies, leading to degraded query performance and reduced system effectiveness. We present Sieve, a middleware for relational DBMSs that combines query rewriting and caching to optimize FGAC policy enforcement. Sieve rewrites a query with guarded expressions that group and filter policies and can efficiently use indexes in the DBMS. It also integrates a caching mechanism with an effective replacement strategy and a refresh mechanism to adapt to dynamic workloads. Experiments on two DBMSs with real and synthetic datasets show that Sieve scales to large datasets and policy corpora, maintaining low query latency and system load and improving policy evaluation performance by between 2x and 10x on workloads with 200 to 1,200 policies. The caching extension further improves query performance by between 6 and 22 percent under dynamic workloads, especially with larger cache sizes. These results highlight Sieve's applicability for real-time access control in smart environments and its support for efficient, scalable management of user preferences and privacy policies.", "AI": {"tldr": "Sieve\u662f\u4e00\u4e2a\u5173\u7cfb\u578b\u6570\u636e\u5e93\u4e2d\u95f4\u4ef6\uff0c\u901a\u8fc7\u67e5\u8be2\u91cd\u5199\u548c\u7f13\u5b58\u673a\u5236\u4f18\u5316\u7ec6\u7c92\u5ea6\u8bbf\u95ee\u63a7\u5236\u7b56\u7565\u6267\u884c\uff0c\u5728200-1200\u6761\u7b56\u7565\u4e0b\u63d0\u5347\u6027\u80fd2-10\u500d\uff0c\u7f13\u5b58\u673a\u5236\u5728\u52a8\u6001\u5de5\u4f5c\u8d1f\u8f7d\u4e0b\u8fdb\u4e00\u6b65\u6539\u5584\u6027\u80fd6-22%\u3002", "motivation": "\u667a\u80fd\u6280\u672f\u666e\u53ca\u548cGDPR\u3001CPRA\u7b49\u9690\u79c1\u6cd5\u89c4\u53d1\u5c55\u589e\u52a0\u4e86\u5bf9\u7ec6\u7c92\u5ea6\u8bbf\u95ee\u63a7\u5236\u7b56\u7565\u7ba1\u7406\u7684\u9700\u6c42\uff0c\u73b0\u6709\u65b9\u6cd5\u65e0\u6cd5\u6269\u5c55\u5230\u6570\u5343\u6761\u7b56\u7565\uff0c\u5bfc\u81f4\u67e5\u8be2\u6027\u80fd\u4e0b\u964d\u548c\u7cfb\u7edf\u6548\u7387\u964d\u4f4e\u3002", "method": "\u7ed3\u5408\u67e5\u8be2\u91cd\u5199\u548c\u7f13\u5b58\u673a\u5236\uff1a\u4f7f\u7528\u4fdd\u62a4\u8868\u8fbe\u5f0f\u91cd\u5199\u67e5\u8be2\u6765\u5206\u7ec4\u548c\u8fc7\u6ee4\u7b56\u7565\uff0c\u6709\u6548\u5229\u7528\u6570\u636e\u5e93\u7d22\u5f15\uff1b\u96c6\u6210\u5177\u6709\u6709\u6548\u66ff\u6362\u7b56\u7565\u548c\u5237\u65b0\u673a\u5236\u7684\u7f13\u5b58\u673a\u5236\u4ee5\u9002\u5e94\u52a8\u6001\u5de5\u4f5c\u8d1f\u8f7d\u3002", "result": "\u5728\u4e24\u4e2a\u6570\u636e\u5e93\u7ba1\u7406\u7cfb\u7edf\u4e0a\u7684\u5b9e\u9a8c\u663e\u793a\uff0cSieve\u53ef\u6269\u5c55\u5230\u5927\u578b\u6570\u636e\u96c6\u548c\u7b56\u7565\u5e93\uff0c\u4fdd\u6301\u4f4e\u67e5\u8be2\u5ef6\u8fdf\u548c\u7cfb\u7edf\u8d1f\u8f7d\uff0c\u5728200-1200\u6761\u7b56\u7565\u7684\u5de5\u4f5c\u8d1f\u8f7d\u4e0b\u5c06\u7b56\u7565\u8bc4\u4f30\u6027\u80fd\u63d0\u9ad82-10\u500d\u3002\u7f13\u5b58\u6269\u5c55\u5728\u52a8\u6001\u5de5\u4f5c\u8d1f\u8f7d\u4e0b\u8fdb\u4e00\u6b65\u5c06\u67e5\u8be2\u6027\u80fd\u63d0\u9ad86-22%\uff0c\u7279\u522b\u662f\u5bf9\u4e8e\u8f83\u5927\u7684\u7f13\u5b58\u5927\u5c0f\u3002", "conclusion": "Sieve\u9002\u7528\u4e8e\u667a\u80fd\u73af\u5883\u4e2d\u7684\u5b9e\u65f6\u8bbf\u95ee\u63a7\u5236\uff0c\u652f\u6301\u9ad8\u6548\u3001\u53ef\u6269\u5c55\u7684\u7528\u6237\u504f\u597d\u548c\u9690\u79c1\u7b56\u7565\u7ba1\u7406\u3002"}}
{"id": "2511.13998", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2511.13998", "abs": "https://arxiv.org/abs/2511.13998", "authors": ["Jielin Qiu", "Zuxin Liu", "Zhiwei Liu", "Rithesh Murthy", "Jianguo Zhang", "Haolin Chen", "Shiyu Wang", "Ming Zhu", "Liangwei Yang", "Juntao Tan", "Roshan Ram", "Akshara Prabhakar", "Tulika Awalgaonkar", "Zixiang Chen", "Zhepeng Cen", "Cheng Qian", "Shelby Heinecke", "Weiran Yao", "Silvio Savarese", "Caiming Xiong", "Huan Wang"], "title": "LoCoBench-Agent: An Interactive Benchmark for LLM Agents in Long-Context Software Engineering", "comment": "54-pages", "summary": "As large language models (LLMs) evolve into sophisticated autonomous agents capable of complex software development tasks, evaluating their real-world capabilities becomes critical. While existing benchmarks like LoCoBench~\\cite{qiu2025locobench} assess long-context code understanding, they focus on single-turn evaluation and cannot capture the multi-turn interactive nature, tool usage patterns, and adaptive reasoning required by real-world coding agents. We introduce \\textbf{LoCoBench-Agent}, a comprehensive evaluation framework specifically designed to assess LLM agents in realistic, long-context software engineering workflows. Our framework extends LoCoBench's 8,000 scenarios into interactive agent environments, enabling systematic evaluation of multi-turn conversations, tool usage efficiency, error recovery, and architectural consistency across extended development sessions. We also introduce an evaluation methodology with 9 metrics across comprehension and efficiency dimensions. Our framework provides agents with 8 specialized tools (file operations, search, code analysis) and evaluates them across context lengths ranging from 10K to 1M tokens, enabling precise assessment of long-context performance. Through systematic evaluation of state-of-the-art models, we reveal several key findings: (1) agents exhibit remarkable long-context robustness; (2) comprehension-efficiency trade-off exists with negative correlation, where thorough exploration increases comprehension but reduces efficiency; and (3) conversation efficiency varies dramatically across models, with strategic tool usage patterns differentiating high-performing agents. As the first long-context LLM agent benchmark for software engineering, LoCoBench-Agent establishes a rigorous foundation for measuring agent capabilities, identifying performance gaps, and advancing autonomous software development at scale.", "AI": {"tldr": "LoCoBench-Agent\u662f\u4e00\u4e2a\u4e13\u95e8\u8bc4\u4f30LLM\u667a\u80fd\u4f53\u5728\u771f\u5b9e\u957f\u4e0a\u4e0b\u6587\u8f6f\u4ef6\u5de5\u7a0b\u5de5\u4f5c\u6d41\u7a0b\u4e2d\u7684\u6846\u67b6\uff0c\u901a\u8fc7\u591a\u8f6e\u4ea4\u4e92\u3001\u5de5\u5177\u4f7f\u7528\u548c\u9519\u8bef\u6062\u590d\u7b49\u7ef4\u5ea6\u7cfb\u7edf\u8bc4\u4f30\u667a\u80fd\u4f53\u80fd\u529b\u3002", "motivation": "\u73b0\u6709\u57fa\u51c6\u5982LoCoBench\u4e3b\u8981\u5173\u6ce8\u5355\u8f6e\u4ee3\u7801\u7406\u89e3\u8bc4\u4f30\uff0c\u65e0\u6cd5\u6355\u6349\u771f\u5b9e\u7f16\u7801\u667a\u80fd\u4f53\u6240\u9700\u7684\u591a\u8f6e\u4ea4\u4e92\u3001\u5de5\u5177\u4f7f\u7528\u6a21\u5f0f\u548c\u81ea\u9002\u5e94\u63a8\u7406\u80fd\u529b\u3002", "method": "\u5c06LoCoBench\u76848000\u4e2a\u573a\u666f\u6269\u5c55\u5230\u4ea4\u4e92\u5f0f\u667a\u80fd\u4f53\u73af\u5883\uff0c\u63d0\u4f9b8\u79cd\u4e13\u7528\u5de5\u5177\uff0c\u572810K\u52301M token\u7684\u4e0a\u4e0b\u6587\u957f\u5ea6\u8303\u56f4\u5185\u8bc4\u4f30\u667a\u80fd\u4f53\u6027\u80fd\uff0c\u4f7f\u75289\u4e2a\u8de8\u7406\u89e3\u548c\u6548\u7387\u7ef4\u5ea6\u7684\u6307\u6807\u3002", "result": "\u8bc4\u4f30\u53d1\u73b0\uff1a(1)\u667a\u80fd\u4f53\u8868\u73b0\u51fa\u663e\u8457\u7684\u957f\u4e0a\u4e0b\u6587\u9c81\u68d2\u6027\uff1b(2)\u7406\u89e3\u4e0e\u6548\u7387\u5b58\u5728\u8d1f\u76f8\u5173\u7684\u6743\u8861\uff1b(3)\u4e0d\u540c\u6a21\u578b\u7684\u5bf9\u8bdd\u6548\u7387\u5dee\u5f02\u663e\u8457\uff0c\u7b56\u7565\u6027\u5de5\u5177\u4f7f\u7528\u6a21\u5f0f\u533a\u5206\u9ad8\u6027\u80fd\u667a\u80fd\u4f53\u3002", "conclusion": "LoCoBench-Agent\u4f5c\u4e3a\u9996\u4e2a\u9762\u5411\u8f6f\u4ef6\u5de5\u7a0b\u7684\u957f\u4e0a\u4e0b\u6587LLM\u667a\u80fd\u4f53\u57fa\u51c6\uff0c\u4e3a\u6d4b\u91cf\u667a\u80fd\u4f53\u80fd\u529b\u3001\u8bc6\u522b\u6027\u80fd\u5dee\u8ddd\u548c\u63a8\u8fdb\u5927\u89c4\u6a21\u81ea\u4e3b\u8f6f\u4ef6\u5f00\u53d1\u5efa\u7acb\u4e86\u4e25\u8c28\u57fa\u7840\u3002"}}
{"id": "2511.13738", "categories": ["cs.DC", "cs.AR"], "pdf": "https://arxiv.org/pdf/2511.13738", "abs": "https://arxiv.org/abs/2511.13738", "authors": ["Hyunseok Kwak", "Kyeongwon Lee", "Kyeongpil Min", "Chaebin Jung", "Woojoo Lee"], "title": "TT-Edge: A Hardware-Software Co-Design for Energy-Efficient Tensor-Train Decomposition on Edge AI", "comment": "8 pages, 6 figures, 4 Tables, DATE 2026 accepted paper", "summary": "The growing demands of distributed learning on resource constrained edge devices underscore the importance of efficient on device model compression. Tensor Train Decomposition (TTD) offers high compression ratios with minimal accuracy loss, yet repeated singular value decompositions (SVDs) and matrix multiplications can impose significant latency and energy costs on low power processors. In this work, we present TT-Edge, a hardware software co designed framework aimed at overcoming these challenges. By splitting SVD into two phases--bidiagonalization and diagonalization--TT-Edge offloads the most compute intensive tasks to a specialized TTD Engine. This engine integrates tightly with an existing GEMM accelerator, thereby curtailing the frequent matrix vector transfers that often undermine system performance and energy efficiency. Implemented on a RISC-V-based edge AI processor, TT-Edge achieves a 1.7x speedup compared to a GEMM only baseline when compressing a ResNet 32 model via TTD, while reducing overall energy usage by 40.2 percent. These gains come with only a 4 percent increase in total power and minimal hardware overhead, enabled by a lightweight design that reuses GEMM resources and employs a shared floating point unit. Our experimental results on both FPGA prototypes and post-synthesis power analysis at 45 nm demonstrate that TT-Edge effectively addresses the latency and energy bottlenecks of TTD based compression in edge environments.", "AI": {"tldr": "TT-Edge\u662f\u4e00\u4e2a\u8f6f\u786c\u4ef6\u534f\u540c\u8bbe\u8ba1\u6846\u67b6\uff0c\u901a\u8fc7\u5728\u8fb9\u7f18AI\u5904\u7406\u5668\u4e0a\u4e13\u95e8\u4f18\u5316\u5f20\u91cf\u8bad\u7ec3\u5206\u89e3(TTD)\u7684\u8ba1\u7b97\u6d41\u7a0b\uff0c\u5b9e\u73b0\u4e861.7\u500d\u52a0\u901f\u548c40.2%\u80fd\u8017\u964d\u4f4e\uff0c\u540c\u65f6\u786c\u4ef6\u5f00\u9500\u6700\u5c0f\u3002", "motivation": "\u5206\u5e03\u5f0f\u5b66\u4e60\u5728\u8d44\u6e90\u53d7\u9650\u8fb9\u7f18\u8bbe\u5907\u4e0a\u7684\u9700\u6c42\u589e\u957f\uff0c\u9700\u8981\u9ad8\u6548\u7684\u8bbe\u5907\u7aef\u6a21\u578b\u538b\u7f29\u3002TTD\u867d\u7136\u63d0\u4f9b\u9ad8\u538b\u7f29\u6bd4\u548c\u4f4e\u7cbe\u5ea6\u635f\u5931\uff0c\u4f46\u5176\u91cd\u590d\u7684SVD\u548c\u77e9\u9635\u4e58\u6cd5\u5728\u4f4e\u529f\u8017\u5904\u7406\u5668\u4e0a\u4f1a\u4ea7\u751f\u663e\u8457\u7684\u5ef6\u8fdf\u548c\u80fd\u8017\u5f00\u9500\u3002", "method": "\u5c06SVD\u5206\u89e3\u4e3a\u53cc\u5bf9\u89d2\u5316\u548c\u5bf9\u89d2\u5316\u4e24\u4e2a\u9636\u6bb5\uff0c\u5c06\u8ba1\u7b97\u5bc6\u96c6\u578b\u4efb\u52a1\u5378\u8f7d\u5230\u4e13\u95e8\u7684TTD\u5f15\u64ce\u3002\u8be5\u5f15\u64ce\u4e0e\u73b0\u6709\u7684GEMM\u52a0\u901f\u5668\u7d27\u5bc6\u96c6\u6210\uff0c\u51cf\u5c11\u9891\u7e41\u7684\u77e9\u9635\u5411\u91cf\u4f20\u8f93\u3002\u91c7\u7528\u8f7b\u91cf\u7ea7\u8bbe\u8ba1\uff0c\u91cd\u7528GEMM\u8d44\u6e90\u5e76\u4f7f\u7528\u5171\u4eab\u6d6e\u70b9\u5355\u5143\u3002", "result": "\u5728RISC-V\u8fb9\u7f18AI\u5904\u7406\u5668\u4e0a\u538b\u7f29ResNet-32\u6a21\u578b\u65f6\uff0c\u76f8\u6bd4\u4ec5\u4f7f\u7528GEMM\u7684\u57fa\u7ebf\uff0c\u5b9e\u73b01.7\u500d\u52a0\u901f\uff0c\u603b\u80fd\u8017\u964d\u4f4e40.2%\uff0c\u603b\u529f\u8017\u4ec5\u589e\u52a04%\uff0c\u786c\u4ef6\u5f00\u9500\u6700\u5c0f\u3002", "conclusion": "TT-Edge\u6709\u6548\u89e3\u51b3\u4e86\u8fb9\u7f18\u73af\u5883\u4e2d\u57fa\u4e8eTTD\u538b\u7f29\u7684\u5ef6\u8fdf\u548c\u80fd\u8017\u74f6\u9888\u95ee\u9898\uff0c\u901a\u8fc7\u8f6f\u786c\u4ef6\u534f\u540c\u8bbe\u8ba1\u5b9e\u73b0\u4e86\u9ad8\u6548\u80fd\u6548\u6bd4\u7684\u6a21\u578b\u538b\u7f29\u3002"}}
{"id": "2511.14002", "categories": ["cs.SE", "cs.AI", "cs.LG", "cs.PL"], "pdf": "https://arxiv.org/pdf/2511.14002", "abs": "https://arxiv.org/abs/2511.14002", "authors": ["Chengpeng Li", "Farnaz Behrang", "August Shi", "Peng Liu"], "title": "FlakyGuard: Automatically Fixing Flaky Tests at Industry Scale", "comment": "To appear in ASE 2025", "summary": "Flaky tests that non-deterministically pass or fail waste developer time and slow release cycles. While large language models (LLMs) show promise for automatically repairing flaky tests, existing approaches like FlakyDoctor fail in industrial settings due to the context problem: providing either too little context (missing critical production code) or too much context (overwhelming the LLM with irrelevant information). We present FlakyGuard, which addresses this problem by treating code as a graph structure and using selective graph exploration to find only the most relevant context. Evaluation on real-world flaky tests from industrial repositories shows that FlakyGuard repairs 47.6 % of reproducible flaky tests with 51.8 % of the fixes accepted by developers. Besides it outperforms state-of-the-art approaches by at least 22 % in repair success rate. Developer surveys confirm that 100 % find FlakyGuard's root cause explanations useful.", "AI": {"tldr": "FlakyGuard\u901a\u8fc7\u5c06\u4ee3\u7801\u89c6\u4e3a\u56fe\u7ed3\u6784\u5e76\u4f7f\u7528\u9009\u62e9\u6027\u56fe\u63a2\u7d22\u6765\u627e\u5230\u6700\u76f8\u5173\u7684\u4e0a\u4e0b\u6587\uff0c\u89e3\u51b3\u4e86LLM\u4fee\u590d\u4e0d\u7a33\u5b9a\u6d4b\u8bd5\u65f6\u7684\u4e0a\u4e0b\u6587\u95ee\u9898\uff0c\u5728\u5de5\u4e1a\u73af\u5883\u4e2d\u4fee\u590d\u4e8647.6%\u7684\u53ef\u91cd\u73b0\u4e0d\u7a33\u5b9a\u6d4b\u8bd5\uff0c\u5176\u4e2d51.8%\u7684\u4fee\u590d\u88ab\u5f00\u53d1\u8005\u63a5\u53d7\u3002", "motivation": "\u4e0d\u7a33\u5b9a\u7684\u6d4b\u8bd5\u4f1a\u6d6a\u8d39\u5f00\u53d1\u8005\u65f6\u95f4\u5e76\u51cf\u6162\u53d1\u5e03\u5468\u671f\u3002\u73b0\u6709\u65b9\u6cd5\u5982FlakyDoctor\u5728\u5de5\u4e1a\u73af\u5883\u4e2d\u5931\u8d25\uff0c\u56e0\u4e3a\u5b58\u5728\u4e0a\u4e0b\u6587\u95ee\u9898\uff1a\u63d0\u4f9b\u592a\u5c11\u4e0a\u4e0b\u6587\uff08\u7f3a\u5c11\u5173\u952e\u751f\u4ea7\u4ee3\u7801\uff09\u6216\u592a\u591a\u4e0a\u4e0b\u6587\uff08\u7528\u65e0\u5173\u4fe1\u606f\u6df9\u6ca1LLM\uff09\u3002", "method": "FlakyGuard\u5c06\u4ee3\u7801\u89c6\u4e3a\u56fe\u7ed3\u6784\uff0c\u5e76\u4f7f\u7528\u9009\u62e9\u6027\u56fe\u63a2\u7d22\u6765\u4ec5\u627e\u5230\u6700\u76f8\u5173\u7684\u4e0a\u4e0b\u6587\u3002", "result": "\u5728\u5de5\u4e1a\u5b58\u50a8\u5e93\u7684\u771f\u5b9e\u4e16\u754c\u4e0d\u7a33\u5b9a\u6d4b\u8bd5\u8bc4\u4f30\u4e2d\uff0cFlakyGuard\u4fee\u590d\u4e8647.6%\u7684\u53ef\u91cd\u73b0\u4e0d\u7a33\u5b9a\u6d4b\u8bd5\uff0c\u5176\u4e2d51.8%\u7684\u4fee\u590d\u88ab\u5f00\u53d1\u8005\u63a5\u53d7\u3002\u6bd4\u6700\u5148\u8fdb\u65b9\u6cd5\u5728\u4fee\u590d\u6210\u529f\u7387\u4e0a\u81f3\u5c11\u9ad8\u51fa22%\u3002\u5f00\u53d1\u8005\u8c03\u67e5\u786e\u8ba4100%\u8ba4\u4e3aFlakyGuard\u7684\u6839\u672c\u539f\u56e0\u89e3\u91ca\u6709\u7528\u3002", "conclusion": "FlakyGuard\u901a\u8fc7\u9009\u62e9\u6027\u56fe\u63a2\u7d22\u6709\u6548\u89e3\u51b3\u4e86LLM\u4fee\u590d\u4e0d\u7a33\u5b9a\u6d4b\u8bd5\u65f6\u7684\u4e0a\u4e0b\u6587\u95ee\u9898\uff0c\u5728\u5de5\u4e1a\u73af\u5883\u4e2d\u53d6\u5f97\u4e86\u663e\u8457\u6548\u679c\u3002"}}
{"id": "2511.13751", "categories": ["cs.DC", "cs.AR", "cs.PL"], "pdf": "https://arxiv.org/pdf/2511.13751", "abs": "https://arxiv.org/abs/2511.13751", "authors": ["Shinnung Jeong", "Chihyo Ahn", "Huanzhi Pu", "Jisheng Zhao", "Hyesoon Kim", "Blaise Tine"], "title": "Inside VOLT: Designing an Open-Source GPU Compiler", "comment": "11 pages, 10 figures, two tables, two algorithms", "summary": "Recent efforts in open-source GPU research are opening new avenues in a domain that has long been tightly coupled with a few commercial vendors. Emerging open GPU architectures define SIMT functionality through their own ISAs, but executing existing GPU programs and optimizing performance on these ISAs relies on a compiler framework that is technically complex and often undercounted in open hardware development costs.\n  To address this challenge, the Vortex-Optimized Lightweight Toolchain (VOLT) has been proposed. This paper presents its design principles, overall structure, and the key compiler transformations required to support SIMT execution on Vortex. VOLT enables SIMT code generation and optimization across multiple levels of abstraction through a hierarchical design that accommodates diverse front-end languages and open GPU hardware. To ensure extensibility as GPU architectures evolve, VOLT centralizes fundamental SIMT-related analyses and optimizations in the middle-end, allowing them to be reused across front-ends and easily adapted to emerging open-GPU variants. Through two case studies on ISA extensions and host-runtime API, this paper also demonstrates how VOLT can support extensions", "AI": {"tldr": "VOLT\u662f\u4e00\u4e2a\u8f7b\u91cf\u7ea7\u7f16\u8bd1\u5668\u5de5\u5177\u94fe\uff0c\u65e8\u5728\u89e3\u51b3\u5f00\u6e90GPU\u67b6\u6784\u4e2dSIMT\u529f\u80fd\u6267\u884c\u548c\u6027\u80fd\u4f18\u5316\u7684\u6311\u6218\uff0c\u901a\u8fc7\u5206\u5c42\u8bbe\u8ba1\u652f\u6301\u591a\u62bd\u8c61\u7ea7\u522b\u7684\u4ee3\u7801\u751f\u6210\u548c\u4f18\u5316\u3002", "motivation": "\u5f00\u6e90GPU\u67b6\u6784\u9700\u8981\u590d\u6742\u7684\u7f16\u8bd1\u5668\u6846\u67b6\u6765\u6267\u884c\u73b0\u6709GPU\u7a0b\u5e8f\u5e76\u4f18\u5316\u6027\u80fd\uff0c\u4f46\u8fd9\u4e00\u6280\u672f\u590d\u6742\u6027\u5728\u5f00\u6e90\u786c\u4ef6\u5f00\u53d1\u6210\u672c\u4e2d\u5e38\u5e38\u88ab\u4f4e\u4f30\u3002", "method": "\u91c7\u7528\u5206\u5c42\u8bbe\u8ba1\uff0c\u5728\u4e2d\u7aef\u96c6\u4e2d\u5904\u7406SIMT\u76f8\u5173\u5206\u6790\u548c\u4f18\u5316\uff0c\u652f\u6301\u591a\u79cd\u524d\u7aef\u8bed\u8a00\u548c\u5f00\u6e90GPU\u786c\u4ef6\uff0c\u786e\u4fdd\u53ef\u6269\u5c55\u6027\u4ee5\u9002\u5e94\u4e0d\u65ad\u53d1\u5c55\u7684GPU\u67b6\u6784\u3002", "result": "\u901a\u8fc7ISA\u6269\u5c55\u548c\u4e3b\u673a\u8fd0\u884c\u65f6API\u7684\u6848\u4f8b\u7814\u7a76\uff0c\u5c55\u793a\u4e86VOLT\u80fd\u591f\u652f\u6301\u6269\u5c55\uff0c\u5e76\u5b9e\u73b0\u8de8\u524d\u7aef\u548c\u65b0\u5174\u5f00\u6e90GPU\u53d8\u4f53\u7684\u91cd\u7528\u3002", "conclusion": "VOLT\u63d0\u4f9b\u4e86\u4e00\u4e2a\u53ef\u6269\u5c55\u7684\u7f16\u8bd1\u5668\u6846\u67b6\uff0c\u80fd\u591f\u6709\u6548\u652f\u6301\u5f00\u6e90GPU\u67b6\u6784\u7684SIMT\u6267\u884c\u548c\u4f18\u5316\u9700\u6c42\uff0c\u4e3a\u5f00\u6e90GPU\u751f\u6001\u7cfb\u7edf\u7684\u53d1\u5c55\u63d0\u4f9b\u4e86\u91cd\u8981\u5de5\u5177\u652f\u6301\u3002"}}
{"id": "2511.14022", "categories": ["cs.SE", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2511.14022", "abs": "https://arxiv.org/abs/2511.14022", "authors": ["Pradeep Kumar Sharma", "Ishaan Puri", "Mantinder Jit Singh", "Swapnil Shivaprasad", "Hritvik Shrivastava"], "title": "Keeping Code-Aware LLMs Fresh: Full Refresh, In-Context Deltas, and Incremental Fine-Tuning", "comment": null, "summary": "Modern codebases evolve continuously: files are renamed or deleted; public APIs drift; behavior shifts within otherwise familiar modules. A model trained yesterday to map a developer's natural-language question to the exact set of repository file paths that matter will degrade tomorrow, even if the questions themselves look unchanged. In this paper we study, at system scale and across several widely used repositories, how to keep such a model fresh without surrendering retention on earlier code. We frame freshness as a form of domain drift between a base snapshot and the current HEAD, and we compare three families of update strategies: (A) Full Refresh, retraining the entire model at the new snapshot; (B) In-Context Learning (ICL) that injects recent deltas (raw git diffs or concise English summaries) at inference; and (C) Incremental Fine-Tuning (Inc-FT) on delta-derived training sets, with carefully controlled NEW:OLD mixing to mitigate catastrophic forgetting. We contribute an alias-aware evaluation protocol that credits rename while never rewarding deleted paths, and a practical Forgetting Probe that quantifies residual emissions of obsolete paths. Across Flask, SQLAlchemy, Pandas, and Poetry, Inc-FT with old-aware mixes delivers the best overall balance on mixed sets, ICL with English delta summaries delivers the fastest new-code lift when training is not feasible, and Full Refresh remains the ceiling when maximum NEW accuracy matters. We also compare Git-diff Inc-FT to full-file Inc-FT, showing that diffs excel in rename/delete-heavy windows while full-file context wins in behavior-change-heavy windows.", "AI": {"tldr": "\u8be5\u8bba\u6587\u7814\u7a76\u4e86\u5982\u4f55\u5728\u4ee3\u7801\u5e93\u6301\u7eed\u6f14\u5316\u7684\u73af\u5883\u4e2d\u4fdd\u6301\u4ee3\u7801\u641c\u7d22\u6a21\u578b\u7684\u65b0\u9c9c\u5ea6\uff0c\u6bd4\u8f83\u4e86\u4e09\u79cd\u66f4\u65b0\u7b56\u7565\uff1a\u5b8c\u5168\u5237\u65b0\u3001\u4e0a\u4e0b\u6587\u5b66\u4e60\u548c\u589e\u91cf\u5fae\u8c03\uff0c\u53d1\u73b0\u589e\u91cf\u5fae\u8c03\u7ed3\u5408\u65b0\u65e7\u4ee3\u7801\u6df7\u5408\u8bad\u7ec3\u80fd\u63d0\u4f9b\u6700\u4f73\u5e73\u8861\u3002", "motivation": "\u73b0\u4ee3\u4ee3\u7801\u5e93\u6301\u7eed\u6f14\u5316\u5bfc\u81f4\u8bad\u7ec3\u6a21\u578b\u5feb\u901f\u8fc7\u65f6\uff0c\u9700\u8981\u7814\u7a76\u5982\u4f55\u5728\u4fdd\u6301\u5bf9\u65e7\u4ee3\u7801\u8bb0\u5fc6\u7684\u540c\u65f6\u9002\u5e94\u65b0\u4ee3\u7801\u53d8\u5316\u3002", "method": "\u5c06\u4ee3\u7801\u65b0\u9c9c\u5ea6\u5efa\u6a21\u4e3a\u9886\u57df\u6f02\u79fb\u95ee\u9898\uff0c\u6bd4\u8f83\u4e09\u79cd\u66f4\u65b0\u7b56\u7565\uff1a(A)\u5b8c\u5168\u91cd\u65b0\u8bad\u7ec3\uff1b(B)\u4e0a\u4e0b\u6587\u5b66\u4e60\u6ce8\u5165\u6700\u8fd1\u53d8\u66f4\uff1b(C)\u589e\u91cf\u5fae\u8c03\u7ed3\u5408\u65b0\u65e7\u4ee3\u7801\u6df7\u5408\u8bad\u7ec3\u4ee5\u9632\u6b62\u707e\u96be\u6027\u9057\u5fd8\u3002", "result": "\u5728Flask\u3001SQLAlchemy\u3001Pandas\u548cPoetry\u7b49\u9879\u76ee\u4e2d\uff0c\u589e\u91cf\u5fae\u8c03\u7ed3\u5408\u65b0\u65e7\u4ee3\u7801\u6df7\u5408\u8bad\u7ec3\u5728\u6df7\u5408\u6570\u636e\u96c6\u4e0a\u8868\u73b0\u6700\u4f73\uff0c\u4e0a\u4e0b\u6587\u5b66\u4e60\u5728\u65e0\u6cd5\u8bad\u7ec3\u65f6\u63d0\u4f9b\u6700\u5feb\u7684\u65b0\u4ee3\u7801\u63d0\u5347\uff0c\u5b8c\u5168\u91cd\u65b0\u8bad\u7ec3\u5728\u8ffd\u6c42\u6700\u5927\u65b0\u4ee3\u7801\u51c6\u786e\u7387\u65f6\u4ecd\u662f\u4e0a\u9650\u3002", "conclusion": "\u589e\u91cf\u5fae\u8c03\u662f\u4fdd\u6301\u4ee3\u7801\u641c\u7d22\u6a21\u578b\u65b0\u9c9c\u5ea6\u7684\u6709\u6548\u65b9\u6cd5\uff0c\u80fd\u591f\u5e73\u8861\u65b0\u65e7\u4ee3\u7801\u7684\u4fdd\u7559\u548c\u9002\u5e94\uff0c\u800c\u4e0d\u540c\u7b56\u7565\u9002\u7528\u4e8e\u4e0d\u540c\u573a\u666f\u9700\u6c42\u3002"}}
{"id": "2511.13761", "categories": ["cs.DC", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2511.13761", "abs": "https://arxiv.org/abs/2511.13761", "authors": ["Alexander Acker", "Soeren Becker", "Sasho Nedelkoski", "Dominik Scheinert", "Odej Kao", "Philipp Wiesner"], "title": "What happens when nanochat meets DiLoCo?", "comment": "8pages, 3 figures, technical report", "summary": "Although LLM training is typically centralized with high-bandwidth interconnects and large compute budgets, emerging methods target communication-constrained training in distributed environments. The model trade-offs introduced by this shift remain underexplored, and our goal is to study them.\n  We use the open-source nanochat project, a compact 8K-line full-stack ChatGPT-like implementation containing tokenization, pretraining, fine-tuning, and serving, as a controlled baseline. We implement the DiLoCo algorithm as a lightweight wrapper over nanochat's training loop, performing multiple local steps per worker before synchronization with an outer optimizer, effectively reducing communication by orders of magnitude. This inner-outer training is compared against a standard data-parallel (DDP) setup. Because nanochat is small and inspectable, it enables controlled pipeline adaptations and allows direct comparison with the conventional centralized baseline.\n  DiLoCo achieves stable convergence and competitive loss in pretraining but yields worse MMLU, GSM8K, and HumanEval scores after mid-training and SFT. We discover that using DiLoCo-pretrained weights and running mid- and post-training with DDP fails to recover performance, revealing irreversible representation drift from asynchronous updates that impairs downstream alignment. We provide this implementation as an official fork of nanochat on GitHub.", "AI": {"tldr": "\u8bba\u6587\u7814\u7a76\u4e86\u5728\u901a\u4fe1\u53d7\u9650\u7684\u5206\u5e03\u5f0f\u73af\u5883\u4e2d\u4f7f\u7528DiLoCo\u7b97\u6cd5\u8fdb\u884cLLM\u8bad\u7ec3\uff0c\u53d1\u73b0\u867d\u7136\u9884\u8bad\u7ec3\u6536\u655b\u7a33\u5b9a\uff0c\u4f46\u5f02\u6b65\u66f4\u65b0\u4f1a\u5bfc\u81f4\u8868\u793a\u6f02\u79fb\uff0c\u5f71\u54cd\u4e0b\u6e38\u4efb\u52a1\u6027\u80fd\u3002", "motivation": "\u63a2\u7d22\u5728\u901a\u4fe1\u53d7\u9650\u7684\u5206\u5e03\u5f0f\u73af\u5883\u4e2dLLM\u8bad\u7ec3\u5f15\u5165\u7684\u6a21\u578b\u6743\u8861\uff0c\u8fd9\u4e9b\u6743\u8861\u5728\u73b0\u6709\u7814\u7a76\u4e2d\u5c1a\u672a\u5145\u5206\u63a2\u7d22\u3002", "method": "\u4f7f\u7528nanochat\u9879\u76ee\u4f5c\u4e3a\u57fa\u7ebf\uff0c\u5b9e\u73b0DiLoCo\u7b97\u6cd5\u4f5c\u4e3a\u8f7b\u91cf\u7ea7\u5305\u88c5\u5668\uff0c\u5728\u591a\u4e2a\u672c\u5730\u6b65\u9aa4\u540e\u8fdb\u884c\u540c\u6b65\uff0c\u4e0e\u6807\u51c6\u6570\u636e\u5e76\u884c(DDP)\u8bbe\u7f6e\u8fdb\u884c\u6bd4\u8f83\u3002", "result": "DiLoCo\u5728\u9884\u8bad\u7ec3\u4e2d\u5b9e\u73b0\u7a33\u5b9a\u6536\u655b\u548c\u7ade\u4e89\u6027\u635f\u5931\uff0c\u4f46\u5728\u4e2d\u671f\u8bad\u7ec3\u548cSFT\u540e\u4ea7\u751f\u66f4\u5dee\u7684MMLU\u3001GSM8K\u548cHumanEval\u5206\u6570\u3002\u4f7f\u7528DiLoCo\u9884\u8bad\u7ec3\u6743\u91cd\u540e\u5207\u6362\u5230DDP\u4e5f\u65e0\u6cd5\u6062\u590d\u6027\u80fd\u3002", "conclusion": "\u5f02\u6b65\u66f4\u65b0\u4f1a\u5bfc\u81f4\u4e0d\u53ef\u9006\u7684\u8868\u793a\u6f02\u79fb\uff0c\u635f\u5bb3\u4e0b\u6e38\u4efb\u52a1\u7684\u5bf9\u9f50\u80fd\u529b\uff0c\u8fd9\u63ed\u793a\u4e86\u5206\u5e03\u5f0f\u8bad\u7ec3\u4e2d\u7684\u91cd\u8981\u6743\u8861\u3002"}}
{"id": "2511.14062", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2511.14062", "abs": "https://arxiv.org/abs/2511.14062", "authors": ["Shenglin Zhang", "Ziang Chen", "Zijing Que", "Yilun Liu", "Yongqian Sun", "Sicheng Wei", "Dan Pei", "Hailin Li"], "title": "LogPurge: Log Data Purification for Anomaly Detection via Rule-Enhanced Filtering", "comment": null, "summary": "Log anomaly detection, which is critical for identifying system failures and preempting security breaches, detects irregular patterns within large volumes of log data, and impacts domains such as service reliability, performance optimization, and database log analysis. Modern log anomaly detection methods rely on training deep learning models on clean, anomaly-free log sequences. However, obtaining such clean log data requires costly and tedious human labeling, and existing automatic cleaning methods fail to fully integrate the specific characteristics and actual semantics of logs in their purification process. In this paper, we propose a cost-aware, rule-enhanced purification framework, LogPurge, that automatically selects a sufficient subset of normal log sequences from contamination log sequences to train a anomaly detection model. Our approach involves a two-stage filtering algorithm: In the first stage, we use a large language model (LLM) to remove clustered anomalous patterns and enhance system rules to improve LLM's understanding of system logs; in the second stage, we utilize a divide-and-conquer strategy that decomposes the remaining contaminated regions into smaller subproblems, allowing each to be effectively purified through the first stage procedure. Our experiments, conducted on two public datasets and one industrial dataset, show that our method significantly removes an average of 98.74% of anomalies while retaining 82.39% of normal samples. Compared to the latest unsupervised log sample selection algorithms, our method achieves F-1 score improvements of 35.7% and 84.11% on the public datasets, and an impressive 149.72% F-1 improvement on the private dataset, demonstrating the effectiveness of our approach.", "AI": {"tldr": "LogPurge\u662f\u4e00\u4e2a\u6210\u672c\u611f\u77e5\u3001\u89c4\u5219\u589e\u5f3a\u7684\u65e5\u5fd7\u51c0\u5316\u6846\u67b6\uff0c\u80fd\u591f\u81ea\u52a8\u4ece\u53d7\u6c61\u67d3\u7684\u65e5\u5fd7\u5e8f\u5217\u4e2d\u9009\u62e9\u8db3\u591f\u7684\u6b63\u5e38\u5b50\u96c6\u6765\u8bad\u7ec3\u5f02\u5e38\u68c0\u6d4b\u6a21\u578b\uff0c\u89e3\u51b3\u4e86\u83b7\u53d6\u5e72\u51c0\u65e5\u5fd7\u6570\u636e\u7684\u9ad8\u6210\u672c\u95ee\u9898\u3002", "motivation": "\u73b0\u4ee3\u65e5\u5fd7\u5f02\u5e38\u68c0\u6d4b\u65b9\u6cd5\u9700\u8981\u57fa\u4e8e\u5e72\u51c0\u3001\u65e0\u5f02\u5e38\u7684\u65e5\u5fd7\u5e8f\u5217\u8bad\u7ec3\u6df1\u5ea6\u5b66\u4e60\u6a21\u578b\uff0c\u4f46\u83b7\u53d6\u8fd9\u6837\u7684\u5e72\u51c0\u65e5\u5fd7\u6570\u636e\u9700\u8981\u6602\u8d35\u4e14\u7e41\u7410\u7684\u4eba\u5de5\u6807\u6ce8\uff0c\u73b0\u6709\u7684\u81ea\u52a8\u6e05\u7406\u65b9\u6cd5\u672a\u80fd\u5145\u5206\u6574\u5408\u65e5\u5fd7\u7684\u7279\u5b9a\u7279\u5f81\u548c\u5b9e\u9645\u8bed\u4e49\u3002", "method": "\u91c7\u7528\u4e24\u9636\u6bb5\u8fc7\u6ee4\u7b97\u6cd5\uff1a\u7b2c\u4e00\u9636\u6bb5\u4f7f\u7528\u5927\u8bed\u8a00\u6a21\u578b(LLM)\u53bb\u9664\u805a\u7c7b\u5f02\u5e38\u6a21\u5f0f\u5e76\u589e\u5f3a\u7cfb\u7edf\u89c4\u5219\u4ee5\u6539\u8fdbLLM\u5bf9\u7cfb\u7edf\u65e5\u5fd7\u7684\u7406\u89e3\uff1b\u7b2c\u4e8c\u9636\u6bb5\u4f7f\u7528\u5206\u6cbb\u7b56\u7565\u5c06\u5269\u4f59\u6c61\u67d3\u533a\u57df\u5206\u89e3\u4e3a\u66f4\u5c0f\u7684\u5b50\u95ee\u9898\uff0c\u6bcf\u4e2a\u5b50\u95ee\u9898\u901a\u8fc7\u7b2c\u4e00\u9636\u6bb5\u7a0b\u5e8f\u6709\u6548\u51c0\u5316\u3002", "result": "\u5728\u4e24\u4e2a\u516c\u5171\u6570\u636e\u96c6\u548c\u4e00\u4e2a\u5de5\u4e1a\u6570\u636e\u96c6\u4e0a\u7684\u5b9e\u9a8c\u8868\u660e\uff0c\u8be5\u65b9\u6cd5\u5e73\u5747\u79fb\u9664\u4e8698.74%\u7684\u5f02\u5e38\uff0c\u540c\u65f6\u4fdd\u7559\u4e8682.39%\u7684\u6b63\u5e38\u6837\u672c\u3002\u4e0e\u6700\u65b0\u7684\u65e0\u76d1\u7763\u65e5\u5fd7\u6837\u672c\u9009\u62e9\u7b97\u6cd5\u76f8\u6bd4\uff0c\u5728\u516c\u5171\u6570\u636e\u96c6\u4e0aF1\u5206\u6570\u5206\u522b\u63d0\u9ad8\u4e8635.7%\u548c84.11%\uff0c\u5728\u79c1\u6709\u6570\u636e\u96c6\u4e0aF1\u5206\u6570\u63d0\u9ad8\u4e86149.72%\u3002", "conclusion": "LogPurge\u6846\u67b6\u5728\u81ea\u52a8\u51c0\u5316\u53d7\u6c61\u67d3\u65e5\u5fd7\u6570\u636e\u65b9\u9762\u8868\u73b0\u51fa\u663e\u8457\u6548\u679c\uff0c\u80fd\u591f\u6709\u6548\u652f\u6301\u65e5\u5fd7\u5f02\u5e38\u68c0\u6d4b\u6a21\u578b\u7684\u8bad\u7ec3\uff0c\u89e3\u51b3\u4e86\u5b9e\u9645\u5e94\u7528\u4e2d\u83b7\u53d6\u5e72\u51c0\u8bad\u7ec3\u6570\u636e\u7684\u6311\u6218\u3002"}}
{"id": "2511.13778", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2511.13778", "abs": "https://arxiv.org/abs/2511.13778", "authors": ["Angelika Schwarz", "Anton Anders", "Cole Brower", "Harun Bayraktar", "John Gunnels", "Kate Clark", "RuQing G. Xu", "Samuel Rodriguez", "Sebastien Cayrols", "Pawe\u0142 Tabaszewski", "Victor Podlozhnyuk"], "title": "Guaranteed DGEMM Accuracy While Using Reduced Precision Tensor Cores Through Extensions of the Ozaki Scheme", "comment": null, "summary": "The rapid growth of artificial intelligence (AI) has made low-precision formats such as FP16, FP8, and, most recently, block-scaled FP4 the primary focus of modern GPUs, where Tensor Cores now deliver orders-of-magnitude higher throughput than traditional FP64 pipelines. This hardware shift has sparked a new line of algorithm research: using low-precision units to emulate double-precision accuracy through schemes such as Ozaki decompositions. We advance this direction with Automatic Dynamic Precision (ADP), a fully GPU-resident framework that makes emulated FP64 matrix multiplication both efficient and reliable. At its core is the Exponent Span Capacity (ESC), a hardware-agnostic estimator that conservatively determines the decomposition parameter (also known as slices) required to achieve FP64-level accuracy. Built on ESC, ADP integrates exception handling, run time heuristics, and seamless fallback to native FP64, ensuring correctness without host-device synchronization or user intervention. Additionally, we further improve Ozaki-style decompositions with an unsigned integer slicing scheme, which increases representational efficiency and reduces computational waste. Validated against recently proposed BLAS grading tests, ADP consistently preserves FP64 fidelity on challenging inputs while incurring less than 10% run time overhead. In a 55-bit mantissa setting, our approach achieves up to 2.3x and 13.2x speedups over native FP64 GEMM on NVIDIA Blackwell GB200 and the RTX Pro 6000 Blackwell Server Edition, respectively. Our results demonstrate that low-precision accelerators can serve as a practical, production-ready foundation for high-fidelity and high-performance scientific computing workloads.", "AI": {"tldr": "ADP\u662f\u4e00\u4e2a\u5b8c\u5168\u5728GPU\u4e0a\u8fd0\u884c\u7684\u6846\u67b6\uff0c\u901a\u8fc7\u81ea\u52a8\u52a8\u6001\u7cbe\u5ea6\u548c\u6307\u6570\u8de8\u5ea6\u5bb9\u91cf\u4f30\u8ba1\u5668\uff0c\u4f7f\u7528\u4f4e\u7cbe\u5ea6\u5355\u5143\u6a21\u62df\u53cc\u7cbe\u5ea6\u77e9\u9635\u4e58\u6cd5\uff0c\u5728\u4fdd\u6301FP64\u7cbe\u5ea6\u7684\u540c\u65f6\u5b9e\u73b0\u663e\u8457\u52a0\u901f\u3002", "motivation": "\u73b0\u4ee3GPU\u786c\u4ef6\u8f6c\u5411\u4f4e\u7cbe\u5ea6\u683c\u5f0f\uff08\u5982FP16\u3001FP8\u3001FP4\uff09\uff0c\u4f20\u7edfFP64\u6d41\u6c34\u7ebf\u541e\u5410\u91cf\u8f83\u4f4e\uff0c\u9700\u8981\u5229\u7528\u4f4e\u7cbe\u5ea6\u5355\u5143\u6765\u6a21\u62df\u53cc\u7cbe\u5ea6\u7cbe\u5ea6\u4ee5\u652f\u6301\u9ad8\u6027\u80fd\u79d1\u5b66\u8ba1\u7b97\u3002", "method": "\u63d0\u51fa\u81ea\u52a8\u52a8\u6001\u7cbe\u5ea6\uff08ADP\uff09\u6846\u67b6\uff0c\u6838\u5fc3\u662f\u6307\u6570\u8de8\u5ea6\u5bb9\u91cf\uff08ESC\uff09\u4f30\u8ba1\u5668\uff0c\u7ed3\u5408\u5f02\u5e38\u5904\u7406\u3001\u8fd0\u884c\u65f6\u542f\u53d1\u5f0f\u548c\u539f\u751fFP64\u56de\u9000\u673a\u5236\uff0c\u4ee5\u53ca\u65e0\u7b26\u53f7\u6574\u6570\u5207\u7247\u65b9\u6848\u6539\u8fdbOzaki\u5206\u89e3\u3002", "result": "\u572855\u4f4d\u5c3e\u6570\u8bbe\u7f6e\u4e0b\uff0c\u76f8\u6bd4\u539f\u751fFP64 GEMM\uff0c\u5728NVIDIA Blackwell GB200\u4e0a\u5b9e\u73b02.3\u500d\u52a0\u901f\uff0c\u5728RTX Pro 6000 Blackwell Server Edition\u4e0a\u5b9e\u73b013.2\u500d\u52a0\u901f\uff0c\u8fd0\u884c\u65f6\u95f4\u5f00\u9500\u4f4e\u4e8e10%\u3002", "conclusion": "\u4f4e\u7cbe\u5ea6\u52a0\u901f\u5668\u53ef\u4ee5\u4f5c\u4e3a\u9ad8\u4fdd\u771f\u3001\u9ad8\u6027\u80fd\u79d1\u5b66\u8ba1\u7b97\u5de5\u4f5c\u8d1f\u8f7d\u7684\u5b9e\u7528\u3001\u751f\u4ea7\u5c31\u7eea\u57fa\u7840\uff0cADP\u6846\u67b6\u8bc1\u660e\u4e86\u8fd9\u4e00\u53ef\u884c\u6027\u3002"}}
{"id": "2511.14215", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2511.14215", "abs": "https://arxiv.org/abs/2511.14215", "authors": ["Malik Muhammad Umer"], "title": "A Practical Implementation of Customized Scrum-Based Agile Framework in Aerospace Software Development Under DO-178C Constraints", "comment": null, "summary": "The increasing complexity of aerospace systems requires development processes that balance agility with stringent safety and certification demands. This study presents an empirically validated Scrum-based Agile framework tailored for DO-178C compliant, safety-critical aerospace software. The framework adapts core Scrum roles, artifacts, and events to meet certification, verification, and independence objectives. Key enhancements include a multi-disciplinary product ownership model, dual compliance-and-functionality acceptance criteria, independent testing and documentation teams, and dedicated certification liaisons. The approach was evaluated through two comparable aerospace projects-one using the customized Agile process and the other a traditional Waterfall model. Results showed significant improvements: a 76% reduction in Total Effort per Requirement, 75% faster Defect Detection, 78% faster Defect Resolution, and over 50% lower Defect Density, while maintaining full compliance with DO-178C Design Assurance Level A. These findings demonstrate that Agile practices and regulatory compliance can coexist effectively when supported by disciplined tailoring and proactive engagement with certification authorities. The study also notes challenges, including increased V&V effort due to recurring Sprint activities and refactoring inherent to iterative development. Nonetheless, it identifies substantial opportunities for further gains through workflow automation, CI/CD practices, and automated documentation, verification, and configuration management. Future research should expand validation of this framework across the aerospace domain and other safety-critical industries with similar certification requirements.", "AI": {"tldr": "\u63d0\u51fa\u4e00\u4e2a\u7ecf\u8fc7\u5b9e\u8bc1\u9a8c\u8bc1\u7684Scrum\u654f\u6377\u6846\u67b6\uff0c\u4e13\u95e8\u7528\u4e8eDO-178C\u5408\u89c4\u7684\u5b89\u5168\u5173\u952e\u822a\u7a7a\u822a\u5929\u8f6f\u4ef6\uff0c\u76f8\u6bd4\u4f20\u7edf\u7011\u5e03\u6a21\u578b\u663e\u8457\u63d0\u5347\u4e86\u5f00\u53d1\u6548\u7387\u548c\u7f3a\u9677\u5904\u7406\u901f\u5ea6\uff0c\u540c\u65f6\u4fdd\u6301\u5b8c\u5168\u5408\u89c4\u3002", "motivation": "\u822a\u7a7a\u822a\u5929\u7cfb\u7edf\u65e5\u76ca\u590d\u6742\uff0c\u9700\u8981\u5728\u654f\u6377\u6027\u548c\u4e25\u683c\u7684\u5b89\u5168\u8ba4\u8bc1\u8981\u6c42\u4e4b\u95f4\u53d6\u5f97\u5e73\u8861\uff0c\u4f20\u7edf\u5f00\u53d1\u65b9\u6cd5\u96be\u4ee5\u6ee1\u8db3\u73b0\u4ee3\u822a\u7a7a\u822a\u5929\u8f6f\u4ef6\u7684\u5f00\u53d1\u9700\u6c42\u3002", "method": "\u5b9a\u5236\u5316Scrum\u6846\u67b6\uff0c\u5305\u62ec\u591a\u5b66\u79d1\u4ea7\u54c1\u6240\u6709\u6743\u6a21\u578b\u3001\u53cc\u91cd\u9a8c\u6536\u6807\u51c6\u3001\u72ec\u7acb\u6d4b\u8bd5\u548c\u6587\u6863\u56e2\u961f\u3001\u8ba4\u8bc1\u8054\u7edc\u5458\u7b49\u5173\u952e\u589e\u5f3a\u529f\u80fd\uff0c\u5e76\u901a\u8fc7\u4e24\u4e2a\u53ef\u6bd4\u9879\u76ee\u8fdb\u884c\u5b9e\u8bc1\u8bc4\u4f30\u3002", "result": "\u76f8\u6bd4\u7011\u5e03\u6a21\u578b\uff0c\u603b\u9700\u6c42\u5de5\u4f5c\u91cf\u51cf\u5c1176%\uff0c\u7f3a\u9677\u68c0\u6d4b\u901f\u5ea6\u63d0\u534775%\uff0c\u7f3a\u9677\u89e3\u51b3\u901f\u5ea6\u63d0\u534778%\uff0c\u7f3a\u9677\u5bc6\u5ea6\u964d\u4f4e50%\u4ee5\u4e0a\uff0c\u540c\u65f6\u4fdd\u6301DO-178C\u8bbe\u8ba1\u4fdd\u8bc1\u7b49\u7ea7A\u7684\u5b8c\u5168\u5408\u89c4\u3002", "conclusion": "\u654f\u6377\u5b9e\u8df5\u4e0e\u76d1\u7ba1\u5408\u89c4\u53ef\u4ee5\u5171\u5b58\uff0c\u4f46\u9700\u8981\u4e25\u683c\u7684\u5b9a\u5236\u5316\u548c\u4e0e\u8ba4\u8bc1\u673a\u6784\u7684\u79ef\u6781\u5408\u4f5c\uff0c\u672a\u6765\u53ef\u901a\u8fc7\u81ea\u52a8\u5316\u3001CI/CD\u7b49\u8fdb\u4e00\u6b65\u4f18\u5316\uff0c\u8be5\u6846\u67b6\u53ef\u63a8\u5e7f\u5230\u5176\u4ed6\u5b89\u5168\u5173\u952e\u884c\u4e1a\u3002"}}
{"id": "2511.13779", "categories": ["cs.DC", "cs.AI", "cs.LG", "cs.NI", "eess.IV"], "pdf": "https://arxiv.org/pdf/2511.13779", "abs": "https://arxiv.org/abs/2511.13779", "authors": ["Mohammad Abdi", "Francesca Meneghello", "Francesco Restuccia"], "title": "Semantic Multiplexing", "comment": null, "summary": "Mobile devices increasingly require the parallel execution of several computing tasks offloaded at the wireless edge. Existing communication systems only support parallel transmissions at the bit level, which fundamentally limits the number of tasks that can be concurrently processed. To address this bottleneck, this paper introduces the new concept of Semantic Multiplexing. Our approach shifts stream multiplexing from bits to tasks by merging multiple task-related compressed representations into a single semantic representation. As such, Semantic Multiplexing can multiplex more tasks than the number of physical channels without adding antennas or widening bandwidth by extending the effective degrees of freedom at the semantic layer, without contradicting Shannon capacity rules. We have prototyped Semantic Multiplexing on an experimental testbed with Jetson Orin Nano and millimeter-wave software-defined radios and tested its performance on image classification and sentiment analysis while comparing to several existing baselines in semantic communications. Our experiments demonstrate that Semantic Multiplexing allows jointly processing multiple tasks at the semantic level while maintaining sufficient task accuracy. For example, image classification accuracy drops by less than 4% when increasing from 2 to 8 the number of tasks multiplexed over a 4$\\times$4 channel. Semantic Multiplexing reduces latency, energy consumption, and communication load respectively by up to 8$\\times$, 25$\\times$, and 54$\\times$ compared to the baselines while keeping comparable performance. We pledge to publicly share the complete software codebase and the collected datasets for reproducibility.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u8bed\u4e49\u591a\u8def\u590d\u7528\u65b0\u6982\u5ff5\uff0c\u5c06\u591a\u4efb\u52a1\u538b\u7f29\u8868\u793a\u5408\u5e76\u4e3a\u5355\u4e00\u8bed\u4e49\u8868\u793a\uff0c\u7a81\u7834\u4e86\u4f20\u7edf\u6bd4\u7279\u7ea7\u5e76\u884c\u4f20\u8f93\u7684\u9650\u5236\uff0c\u663e\u8457\u63d0\u5347\u4e86\u591a\u4efb\u52a1\u5e76\u53d1\u5904\u7406\u80fd\u529b\u3002", "motivation": "\u79fb\u52a8\u8bbe\u5907\u9700\u8981\u5728\u65e0\u7ebf\u8fb9\u7f18\u5e76\u884c\u6267\u884c\u591a\u4e2a\u8ba1\u7b97\u4efb\u52a1\uff0c\u4f46\u73b0\u6709\u901a\u4fe1\u7cfb\u7edf\u4ec5\u652f\u6301\u6bd4\u7279\u7ea7\u5e76\u884c\u4f20\u8f93\uff0c\u8fd9\u4ece\u6839\u672c\u4e0a\u9650\u5236\u4e86\u53ef\u5e76\u53d1\u5904\u7406\u7684\u4efb\u52a1\u6570\u91cf\u3002", "method": "\u63d0\u51fa\u8bed\u4e49\u591a\u8def\u590d\u7528\u65b9\u6cd5\uff0c\u5c06\u591a\u4efb\u52a1\u76f8\u5173\u7684\u538b\u7f29\u8868\u793a\u5408\u5e76\u4e3a\u5355\u4e00\u8bed\u4e49\u8868\u793a\uff0c\u5728\u8bed\u4e49\u5c42\u6269\u5c55\u6709\u6548\u81ea\u7531\u5ea6\uff0c\u800c\u4e0d\u8fdd\u53cd\u9999\u519c\u5bb9\u91cf\u89c4\u5219\u3002", "result": "\u5b9e\u9a8c\u8868\u660e\uff0c\u57284\u00d74\u4fe1\u9053\u4e0a\u4ece2\u4e2a\u4efb\u52a1\u589e\u52a0\u52308\u4e2a\u4efb\u52a1\u65f6\uff0c\u56fe\u50cf\u5206\u7c7b\u51c6\u786e\u7387\u4e0b\u964d\u4e0d\u52304%\u3002\u76f8\u6bd4\u57fa\u7ebf\u65b9\u6cd5\uff0c\u5ef6\u8fdf\u964d\u4f4e8\u500d\uff0c\u80fd\u8017\u964d\u4f4e25\u500d\uff0c\u901a\u4fe1\u8d1f\u8f7d\u964d\u4f4e54\u500d\u3002", "conclusion": "\u8bed\u4e49\u591a\u8def\u590d\u7528\u80fd\u591f\u5728\u8bed\u4e49\u5c42\u8054\u5408\u5904\u7406\u591a\u4e2a\u4efb\u52a1\uff0c\u540c\u65f6\u4fdd\u6301\u8db3\u591f\u7684\u4efb\u52a1\u51c6\u786e\u6027\uff0c\u663e\u8457\u63d0\u5347\u4e86\u591a\u4efb\u52a1\u5904\u7406\u7684\u6548\u7387\u548c\u6027\u80fd\u3002"}}
{"id": "2511.14224", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2511.14224", "abs": "https://arxiv.org/abs/2511.14224", "authors": ["Anji Li", "Mingwei Liu", "Zhenxi Chen", "Zheng Pei", "Zike Li", "Dekun Dai", "Yanlin Wang", "Zibin Zheng"], "title": "KTester: Leveraging Domain and Testing Knowledge for More Effective LLM-based Test Generation", "comment": "13 pages, 11 figures", "summary": "Automated unit test generation using large language models (LLMs) holds great promise but often struggles with generating tests that are both correct and maintainable in real-world projects. This paper presents KTester, a novel framework that integrates project-specific knowledge and testing domain knowledge to enhance LLM-based test generation. Our approach first extracts project structure and usage knowledge through static analysis, which provides rich context for the model. It then employs a testing-domain-knowledge-guided separation of test case design and test method generation, combined with a multi-perspective prompting strategy that guides the LLM to consider diverse testing heuristics. The generated tests follow structured templates, improving clarity and maintainability. We evaluate KTester on multiple open-source projects, comparing it against state-of-the-art LLM-based baselines using automatic correctness and coverage metrics, as well as a human study assessing readability and maintainability. Results demonstrate that KTester significantly outperforms existing methods across six key metrics, improving execution pass rate by 5.69% and line coverage by 8.83% over the strongest baseline, while requiring less time and generating fewer test cases. Human evaluators also rate the tests produced by KTester significantly higher in terms of correctness, readability, and maintainability, confirming the practical advantages of our knowledge-driven framework.", "AI": {"tldr": "KTester\u662f\u4e00\u4e2a\u96c6\u6210\u9879\u76ee\u7279\u5b9a\u77e5\u8bc6\u548c\u6d4b\u8bd5\u9886\u57df\u77e5\u8bc6\u7684LLM\u6d4b\u8bd5\u751f\u6210\u6846\u67b6\uff0c\u901a\u8fc7\u9759\u6001\u5206\u6790\u63d0\u53d6\u9879\u76ee\u7ed3\u6784\u548c\u4f7f\u7528\u77e5\u8bc6\uff0c\u91c7\u7528\u6d4b\u8bd5\u9886\u57df\u77e5\u8bc6\u5f15\u5bfc\u7684\u6d4b\u8bd5\u7528\u4f8b\u8bbe\u8ba1\u4e0e\u6d4b\u8bd5\u65b9\u6cd5\u751f\u6210\u5206\u79bb\u7b56\u7565\uff0c\u7ed3\u5408\u591a\u89c6\u89d2\u63d0\u793a\uff0c\u663e\u8457\u63d0\u5347\u6d4b\u8bd5\u751f\u6210\u7684\u8d28\u91cf\u548c\u53ef\u7ef4\u62a4\u6027\u3002", "motivation": "\u73b0\u6709\u7684\u57fa\u4e8eLLM\u7684\u81ea\u52a8\u5316\u5355\u5143\u6d4b\u8bd5\u751f\u6210\u65b9\u6cd5\u5728\u771f\u5b9e\u9879\u76ee\u4e2d\u5f80\u5f80\u96be\u4ee5\u751f\u6210\u65e2\u6b63\u786e\u53c8\u53ef\u7ef4\u62a4\u7684\u6d4b\u8bd5\u7528\u4f8b\uff0c\u9700\u8981\u66f4\u597d\u5730\u6574\u5408\u9879\u76ee\u7279\u5b9a\u77e5\u8bc6\u548c\u6d4b\u8bd5\u9886\u57df\u77e5\u8bc6\u3002", "method": "KTester\u6846\u67b6\u901a\u8fc7\u9759\u6001\u5206\u6790\u63d0\u53d6\u9879\u76ee\u7ed3\u6784\u548c\u4f7f\u7528\u77e5\u8bc6\uff0c\u91c7\u7528\u6d4b\u8bd5\u9886\u57df\u77e5\u8bc6\u5f15\u5bfc\u7684\u6d4b\u8bd5\u7528\u4f8b\u8bbe\u8ba1\u4e0e\u6d4b\u8bd5\u65b9\u6cd5\u751f\u6210\u5206\u79bb\u7b56\u7565\uff0c\u7ed3\u5408\u591a\u89c6\u89d2\u63d0\u793a\u6280\u672f\uff0c\u5f15\u5bfcLLM\u8003\u8651\u591a\u6837\u5316\u7684\u6d4b\u8bd5\u542f\u53d1\u5f0f\u65b9\u6cd5\uff0c\u5e76\u9075\u5faa\u7ed3\u6784\u5316\u6a21\u677f\u751f\u6210\u6d4b\u8bd5\u3002", "result": "\u5728\u591a\u4e2a\u5f00\u6e90\u9879\u76ee\u4e0a\u7684\u8bc4\u4f30\u663e\u793a\uff0cKTester\u5728\u516d\u4e2a\u5173\u952e\u6307\u6807\u4e0a\u663e\u8457\u4f18\u4e8e\u73b0\u6709\u65b9\u6cd5\uff0c\u6267\u884c\u901a\u8fc7\u7387\u63d0\u53475.69%\uff0c\u884c\u8986\u76d6\u7387\u63d0\u53478.83%\uff0c\u540c\u65f6\u9700\u8981\u66f4\u5c11\u65f6\u95f4\u548c\u751f\u6210\u66f4\u5c11\u7684\u6d4b\u8bd5\u7528\u4f8b\u3002\u4eba\u5de5\u8bc4\u4f30\u4e5f\u786e\u8ba4KTester\u751f\u6210\u7684\u6d4b\u8bd5\u5728\u6b63\u786e\u6027\u3001\u53ef\u8bfb\u6027\u548c\u53ef\u7ef4\u62a4\u6027\u65b9\u9762\u8bc4\u5206\u66f4\u9ad8\u3002", "conclusion": "KTester\u8bc1\u660e\u4e86\u77e5\u8bc6\u9a71\u52a8\u6846\u67b6\u5728\u63d0\u5347LLM\u6d4b\u8bd5\u751f\u6210\u8d28\u91cf\u65b9\u9762\u7684\u6709\u6548\u6027\uff0c\u901a\u8fc7\u6574\u5408\u9879\u76ee\u7279\u5b9a\u77e5\u8bc6\u548c\u6d4b\u8bd5\u9886\u57df\u77e5\u8bc6\uff0c\u80fd\u591f\u751f\u6210\u66f4\u6b63\u786e\u3001\u53ef\u8bfb\u548c\u53ef\u7ef4\u62a4\u7684\u6d4b\u8bd5\u7528\u4f8b\u3002"}}
{"id": "2511.13804", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2511.13804", "abs": "https://arxiv.org/abs/2511.13804", "authors": ["Temitayo Adefemi"], "title": "Do MPI Derived Datatypes Actually Help? A Single-Node Cross-Implementation Study on Shared-Memory Communication", "comment": "9 pages, 6 figures", "summary": "MPI's derived datatypes (DDTs) promise easier, copy-free communication of non-contiguous data, yet their practical performance remains debated and is often reported only for a single MPI stack. We present a cross-implementation assessment using three 2D applications: a Jacobi CFD solver, Conway's Game of Life, and a lattice-based image reconstruction. Each application is written in two ways: (i) a BASIC version with manual packing and unpacking of non-contiguous regions and (ii) a DDT version using MPI_Type_vector and MPI_Type_create_subarray with correct true extent via MPI_Type_create_resized. For API parity, we benchmark identical communication semantics: non-blocking point-to-point (Irecv/Isend + Waitall), neighborhood collectives (MPI_Neighbor_alltoallw), and MPI-4 persistent operations (*_init). We run strong and weak scaling on 1-4 ranks, validate bitwise-identical halos, and evaluate four widely used MPI implementations: MPICH, Open MPI, Intel MPI, and MVAPICH2 on a single ARCHER2 node. Results are mixed. DDTs can be fastest, for example for the image reconstruction code on Intel MPI and MPICH, but can also be among the slowest on other stacks, such as Open MPI and MVAPICH2 for the same code. For the CFD solver, BASIC variants generally outperform DDTs across semantics, whereas for Game of Life the ranking flips depending on the MPI library. We also observe stack-specific anomalies, for example MPICH slowdowns with DDT neighborhood and persistent modes. Overall, no strategy dominates across programs, semantics, and MPI stacks; performance portability for DDTs is not guaranteed. We therefore recommend profiling both DDT-based and manual-packing designs under the intended MPI implementation and communication mode. Our study is limited to a single node and does not analyze memory overhead; multi-node and GPU-aware paths are left for future work.", "AI": {"tldr": "MPI\u6d3e\u751f\u6570\u636e\u7c7b\u578b(DDTs)\u7684\u6027\u80fd\u5728\u4e0d\u540cMPI\u5b9e\u73b0\u4e2d\u8868\u73b0\u4e0d\u4e00\uff0c\u6ca1\u6709\u7edf\u4e00\u7684\u6027\u80fd\u4f18\u52bf\uff0c\u5efa\u8bae\u6839\u636e\u5177\u4f53MPI\u5b9e\u73b0\u548c\u901a\u4fe1\u6a21\u5f0f\u8fdb\u884c\u6027\u80fd\u5206\u6790", "motivation": "\u8bc4\u4f30MPI\u6d3e\u751f\u6570\u636e\u7c7b\u578b\u5728\u5b9e\u9645\u5e94\u7528\u4e2d\u7684\u6027\u80fd\u8868\u73b0\uff0c\u6f84\u6e05\u5173\u4e8eDDTs\u6027\u80fd\u7684\u4e89\u8bae\uff0c\u63d0\u4f9b\u8de8\u5b9e\u73b0\u7684\u6027\u80fd\u5bf9\u6bd4", "method": "\u4f7f\u7528\u4e09\u4e2a2D\u5e94\u7528\uff08Jacobi CFD\u6c42\u89e3\u5668\u3001\u5eb7\u5a01\u751f\u547d\u6e38\u620f\u3001\u57fa\u4e8e\u683c\u70b9\u7684\u56fe\u50cf\u91cd\u5efa\uff09\uff0c\u6bcf\u4e2a\u5e94\u7528\u5206\u522b\u5b9e\u73b0\u624b\u52a8\u6253\u5305\u7248\u672c\u548cDDT\u7248\u672c\uff0c\u5728\u56db\u4e2a\u4e3b\u6d41MPI\u5b9e\u73b0(MPICH\u3001Open MPI\u3001Intel MPI\u3001MVAPICH2)\u4e0a\u6d4b\u8bd5\u5f3a\u6269\u5c55\u548c\u5f31\u6269\u5c55", "result": "\u7ed3\u679c\u6df7\u5408\uff1aDDTs\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\u6700\u5feb\uff08\u5982\u56fe\u50cf\u91cd\u5efa\u5728Intel MPI\u548cMPICH\u4e0a\uff09\uff0c\u4f46\u5728\u5176\u4ed6\u60c5\u51b5\u4e0b\u6700\u6162\uff08\u5982Open MPI\u548cMVAPICH2\u4e0a\u7684\u76f8\u540c\u4ee3\u7801\uff09\u3002CFD\u6c42\u89e3\u5668\u4e2d\u624b\u52a8\u6253\u5305\u7248\u672c\u666e\u904d\u4f18\u4e8eDDTs\uff0c\u800c\u751f\u547d\u6e38\u620f\u4e2d\u6027\u80fd\u6392\u540d\u56e0MPI\u5e93\u800c\u5f02", "conclusion": "\u6ca1\u6709\u5355\u4e00\u7b56\u7565\u5728\u6240\u6709\u7a0b\u5e8f\u3001\u901a\u4fe1\u8bed\u4e49\u548cMPI\u5b9e\u73b0\u4e2d\u5360\u4f18\uff0cDDTs\u7684\u6027\u80fd\u53ef\u79fb\u690d\u6027\u65e0\u6cd5\u4fdd\u8bc1\uff0c\u5efa\u8bae\u5728\u5b9e\u9645\u4f7f\u7528\u7684MPI\u5b9e\u73b0\u548c\u901a\u4fe1\u6a21\u5f0f\u4e0b\u540c\u65f6\u5206\u6790DDT\u548c\u624b\u52a8\u6253\u5305\u8bbe\u8ba1\u7684\u6027\u80fd"}}
{"id": "2511.14367", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2511.14367", "abs": "https://arxiv.org/abs/2511.14367", "authors": ["Dulaji Hidellaarachchi", "Sebastian Baltes", "John Grundy"], "title": "How Does Cognitive Capability and Personality Influence Problem-Solving in Coding Interview Puzzles?", "comment": "11 pages, 8 figures, 7 tables", "summary": "Software engineering is a deeply cognitive activity shaped by individual differences that extend beyond technical skill. This study investigates how cognitive capability and personality traits jointly relate to software problem solving among 80 participants (40 software practitioners, 40 software engineering students). Cognitive capability was measured using Baddeleys three minute grammatical reasoning test, while personality was assessed using the IPIP NEO 50 test. Participants further completed nine interview style problem solving questions. Six questions were related to coding and three were related to logical reasoning. Descriptive and correlational analyses show that practitioners achieved slightly higher grammatical reasoning accuracy and overall task performance than students. Grammatical-reasoning accuracy correlated positively with problem solving performance, indicating that stronger cognitive capability is associated with better performance in coding and logical tasks. Personality performance links were systematic. We identified that the conscientiousness trait correlated most strongly with problem solving and with reasoning accuracy, while the openness to experience trait was positively related to both outcomes. Neuroticism showed small, negative associations with accuracy and performance. Taken together, our results suggest that conscientiousness and openness to experience characteristics complement reasoning accuracy to support software problem solving, whereas elevated negative affect may hinder precision under time pressure. Our findings suggest practical implications for education and industry such as integrating structured reasoning tasks in curricula, and considering personality cognition in recruitment and role allocation. We highlight directions for future research such as longitudinal and task diverse replications with larger samples.", "AI": {"tldr": "\u672c\u7814\u7a76\u63a2\u8ba8\u8ba4\u77e5\u80fd\u529b\u548c\u4eba\u683c\u7279\u8d28\u5982\u4f55\u5171\u540c\u5f71\u54cd\u8f6f\u4ef6\u95ee\u9898\u89e3\u51b3\u80fd\u529b\uff0c\u53d1\u73b0\u8ba4\u77e5\u80fd\u529b\uff08\u8bed\u6cd5\u63a8\u7406\u51c6\u786e\u6027\uff09\u4e0e\u95ee\u9898\u89e3\u51b3\u8868\u73b0\u6b63\u76f8\u5173\uff0c\u5c3d\u8d23\u6027\u548c\u5f00\u653e\u6027\u4eba\u683c\u7279\u8d28\u5bf9\u8f6f\u4ef6\u95ee\u9898\u89e3\u51b3\u6709\u79ef\u6781\u5f71\u54cd\uff0c\u800c\u795e\u7ecf\u8d28\u5219\u6709\u8f7b\u5fae\u8d1f\u9762\u5f71\u54cd\u3002", "motivation": "\u8f6f\u4ef6\u5de5\u7a0b\u662f\u6df1\u5ea6\u8ba4\u77e5\u6d3b\u52a8\uff0c\u53d7\u4e2a\u4f53\u5dee\u5f02\u5f71\u54cd\u3002\u672c\u7814\u7a76\u65e8\u5728\u63a2\u7d22\u8ba4\u77e5\u80fd\u529b\u548c\u4eba\u683c\u7279\u8d28\u5982\u4f55\u5171\u540c\u5f71\u54cd\u8f6f\u4ef6\u95ee\u9898\u89e3\u51b3\u80fd\u529b\uff0c\u4e3a\u6559\u80b2\u548c\u884c\u4e1a\u5b9e\u8df5\u63d0\u4f9b\u6307\u5bfc\u3002", "method": "\u5bf980\u540d\u53c2\u4e0e\u8005\uff0840\u540d\u4ece\u4e1a\u8005\uff0c40\u540d\u5b66\u751f\uff09\u8fdb\u884c\u8ba4\u77e5\u80fd\u529b\u6d4b\u8bd5\uff08Baddeley\u8bed\u6cd5\u63a8\u7406\u6d4b\u8bd5\uff09\u3001\u4eba\u683c\u8bc4\u4f30\uff08IPIP NEO 50\u6d4b\u8bd5\uff09\u548c9\u4e2a\u95ee\u9898\u89e3\u51b3\u4efb\u52a1\uff086\u4e2a\u7f16\u7801\u95ee\u9898\uff0c3\u4e2a\u903b\u8f91\u63a8\u7406\u95ee\u9898\uff09\u3002", "result": "\u4ece\u4e1a\u8005\u5728\u8bed\u6cd5\u63a8\u7406\u51c6\u786e\u6027\u548c\u4efb\u52a1\u8868\u73b0\u4e0a\u7565\u4f18\u4e8e\u5b66\u751f\u3002\u8ba4\u77e5\u80fd\u529b\u4e0e\u95ee\u9898\u89e3\u51b3\u8868\u73b0\u6b63\u76f8\u5173\uff0c\u5c3d\u8d23\u6027\u4eba\u683c\u7279\u8d28\u4e0e\u95ee\u9898\u89e3\u51b3\u548c\u63a8\u7406\u51c6\u786e\u6027\u76f8\u5173\u6027\u6700\u5f3a\uff0c\u5f00\u653e\u6027\u7279\u8d28\u4e5f\u6709\u79ef\u6781\u5f71\u54cd\uff0c\u795e\u7ecf\u8d28\u5219\u4e0e\u51c6\u786e\u6027\u548c\u8868\u73b0\u5448\u8d1f\u76f8\u5173\u3002", "conclusion": "\u5c3d\u8d23\u6027\u548c\u5f00\u653e\u6027\u4eba\u683c\u7279\u8d28\u4e0e\u8ba4\u77e5\u80fd\u529b\u5171\u540c\u652f\u6301\u8f6f\u4ef6\u95ee\u9898\u89e3\u51b3\uff0c\u800c\u8d1f\u9762\u60c5\u7eea\u53ef\u80fd\u5f71\u54cd\u65f6\u95f4\u538b\u529b\u4e0b\u7684\u7cbe\u786e\u6027\u3002\u7814\u7a76\u5bf9\u6559\u80b2\u8bfe\u7a0b\u8bbe\u8ba1\u548c\u884c\u4e1a\u62db\u8058\u5b9e\u8df5\u5177\u6709\u5b9e\u9645\u610f\u4e49\u3002"}}
{"id": "2511.13940", "categories": ["cs.DC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2511.13940", "abs": "https://arxiv.org/abs/2511.13940", "authors": ["Stuart H. Sul", "Simran Arora", "Benjamin F. Spector", "Christopher R\u00e9"], "title": "ParallelKittens: Systematic and Practical Simplification of Multi-GPU AI Kernels", "comment": null, "summary": "Inter-GPU communication has become a major bottleneck for modern AI workloads as models scale and improvements in hardware compute throughput outpace improvements in interconnect bandwidth. Existing systems mitigate this through compute-communication overlap but often fail to meet theoretical peak performance across heterogeneous workloads and new accelerators. Instead of operator-specific techniques, we ask whether a small set of simple, reusable principles can systematically guide the design of optimal multi-GPU kernels. We present ParallelKittens (PK), a minimal CUDA framework that drastically simplifies the development of overlapped multi-GPU kernels. PK extends the ThunderKittens framework and embodies the principles of multi-GPU kernel design through eight core primitives and a unified programming template, derived from a comprehensive analysis of the factors that govern multi-GPU performance$\\unicode{x2014}$data-transfer mechanisms, resource scheduling, and design overheads. We validate PK on both Hopper and Blackwell architectures. With fewer than 50 lines of device code, PK achieves up to $2.33 \\times$ speedup for data- and tensor-parallel workloads, $4.08 \\times$ for sequence-parallel workloads, and $1.22 \\times$ for expert-parallel workloads.", "AI": {"tldr": "ParallelKittens (PK) \u662f\u4e00\u4e2a\u7b80\u5316\u7684 CUDA \u6846\u67b6\uff0c\u901a\u8fc7\u516b\u4e2a\u6838\u5fc3\u539f\u8bed\u548c\u7edf\u4e00\u7f16\u7a0b\u6a21\u677f\uff0c\u7cfb\u7edf\u6027\u5730\u6307\u5bfc\u5f00\u53d1\u6700\u4f18\u7684\u591a GPU \u5185\u6838\uff0c\u663e\u8457\u63d0\u5347\u5f02\u6784\u5de5\u4f5c\u8d1f\u8f7d\u5728\u4e0d\u540c\u52a0\u901f\u5668\u4e0a\u7684\u6027\u80fd\u3002", "motivation": "\u968f\u7740\u6a21\u578b\u89c4\u6a21\u6269\u5927\u548c\u786c\u4ef6\u8ba1\u7b97\u541e\u5410\u91cf\u63d0\u5347\u8d85\u8fc7\u4e92\u8fde\u5e26\u5bbd\u6539\u8fdb\uff0cGPU \u95f4\u901a\u4fe1\u5df2\u6210\u4e3a\u73b0\u4ee3 AI \u5de5\u4f5c\u8d1f\u8f7d\u7684\u4e3b\u8981\u74f6\u9888\u3002\u73b0\u6709\u7cfb\u7edf\u901a\u8fc7\u8ba1\u7b97-\u901a\u4fe1\u91cd\u53e0\u6765\u7f13\u89e3\uff0c\u4f46\u5f80\u5f80\u65e0\u6cd5\u5728\u5f02\u6784\u5de5\u4f5c\u8d1f\u8f7d\u548c\u65b0\u52a0\u901f\u5668\u4e0a\u8fbe\u5230\u7406\u8bba\u5cf0\u503c\u6027\u80fd\u3002", "method": "PK \u6269\u5c55\u4e86 ThunderKittens \u6846\u67b6\uff0c\u901a\u8fc7\u516b\u4e2a\u6838\u5fc3\u539f\u8bed\u548c\u7edf\u4e00\u7f16\u7a0b\u6a21\u677f\u4f53\u73b0\u591a GPU \u5185\u6838\u8bbe\u8ba1\u539f\u5219\uff0c\u57fa\u4e8e\u5bf9\u6570\u636e\u4f20\u8f93\u673a\u5236\u3001\u8d44\u6e90\u8c03\u5ea6\u548c\u8bbe\u8ba1\u5f00\u9500\u7b49\u5f71\u54cd\u591a GPU \u6027\u80fd\u56e0\u7d20\u7684\u7efc\u5408\u5206\u6790\u3002", "result": "\u5728 Hopper \u548c Blackwell \u67b6\u6784\u4e0a\u9a8c\u8bc1\uff0c\u4ec5\u7528\u4e0d\u5230 50 \u884c\u8bbe\u5907\u4ee3\u7801\uff0cPK \u5b9e\u73b0\u4e86\u6570\u636e\u5e76\u884c\u548c tensor \u5e76\u884c\u5de5\u4f5c\u8d1f\u8f7d\u6700\u9ad8 2.33 \u500d\u52a0\u901f\uff0c\u5e8f\u5217\u5e76\u884c\u5de5\u4f5c\u8d1f\u8f7d 4.08 \u500d\u52a0\u901f\uff0c\u4e13\u5bb6\u5e76\u884c\u5de5\u4f5c\u8d1f\u8f7d 1.22 \u500d\u52a0\u901f\u3002", "conclusion": "PK \u8bc1\u660e\u4e86\u901a\u8fc7\u5c11\u91cf\u7b80\u5355\u3001\u53ef\u91cd\u7528\u7684\u539f\u5219\u53ef\u4ee5\u7cfb\u7edf\u6027\u5730\u6307\u5bfc\u8bbe\u8ba1\u6700\u4f18\u7684\u591a GPU \u5185\u6838\uff0c\u663e\u8457\u7b80\u5316\u4e86\u91cd\u53e0\u591a GPU \u5185\u6838\u7684\u5f00\u53d1\u8fc7\u7a0b\u3002"}}
{"id": "2511.14435", "categories": ["cs.SE", "cs.AI", "cs.LO"], "pdf": "https://arxiv.org/pdf/2511.14435", "abs": "https://arxiv.org/abs/2511.14435", "authors": ["Angelo Ferrando"], "title": "Watchdogs and Oracles: Runtime Verification Meets Large Language Models for Autonomous Systems", "comment": "In Proceedings FMAS 2025, arXiv:2511.13245", "summary": "Assuring the safety and trustworthiness of autonomous systems is particularly difficult when learning-enabled components and open environments are involved. Formal methods provide strong guarantees but depend on complete models and static assumptions. Runtime verification (RV) complements them by monitoring executions at run time and, in its predictive variants, by anticipating potential violations. Large language models (LLMs), meanwhile, excel at translating natural language into formal artefacts and recognising patterns in data, yet they remain error-prone and lack formal guarantees. This vision paper argues for a symbiotic integration of RV and LLMs. RV can serve as a guardrail for LLM-driven autonomy, while LLMs can extend RV by assisting specification capture, supporting anticipatory reasoning, and helping to handle uncertainty. We outline how this mutual reinforcement differs from existing surveys and roadmaps, discuss challenges and certification implications, and identify future research directions towards dependable autonomy.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u5c06\u8fd0\u884c\u65f6\u9a8c\u8bc1(RV)\u4e0e\u5927\u8bed\u8a00\u6a21\u578b(LLMs)\u8fdb\u884c\u5171\u751f\u96c6\u6210\uff0cRV\u53ef\u4f5c\u4e3aLLM\u9a71\u52a8\u81ea\u4e3b\u7cfb\u7edf\u7684\u5b89\u5168\u62a4\u680f\uff0c\u800cLLMs\u53ef\u6269\u5c55RV\u7684\u80fd\u529b\uff0c\u5e2e\u52a9\u5904\u7406\u89c4\u8303\u6355\u83b7\u3001\u9884\u671f\u63a8\u7406\u548c\u4e0d\u786e\u5b9a\u6027\u3002", "motivation": "\u786e\u4fdd\u5177\u6709\u5b66\u4e60\u7ec4\u4ef6\u548c\u5f00\u653e\u73af\u5883\u7684\u81ea\u4e3b\u7cfb\u7edf\u7684\u5b89\u5168\u6027\u548c\u53ef\u4fe1\u8d56\u6027\u5177\u6709\u6311\u6218\u6027\u3002\u5f62\u5f0f\u5316\u65b9\u6cd5\u63d0\u4f9b\u5f3a\u4fdd\u8bc1\u4f46\u4f9d\u8d56\u5b8c\u6574\u6a21\u578b\u548c\u9759\u6001\u5047\u8bbe\uff0c\u800cLLMs\u64c5\u957f\u6a21\u5f0f\u8bc6\u522b\u4f46\u7f3a\u4e4f\u5f62\u5f0f\u5316\u4fdd\u8bc1\u4e14\u5bb9\u6613\u51fa\u9519\u3002", "method": "\u63d0\u51faRV\u548cLLMs\u7684\u5171\u751f\u96c6\u6210\u65b9\u6cd5\uff1aRV\u4f5c\u4e3aLLM\u9a71\u52a8\u81ea\u4e3b\u7cfb\u7edf\u7684\u5b89\u5168\u62a4\u680f\uff0cLLMs\u8f85\u52a9RV\u8fdb\u884c\u89c4\u8303\u6355\u83b7\u3001\u652f\u6301\u9884\u671f\u63a8\u7406\u548c\u5904\u7406\u4e0d\u786e\u5b9a\u6027\u3002", "result": "\u8fd9\u79cd\u76f8\u4e92\u589e\u5f3a\u7684\u65b9\u6cd5\u4e0d\u540c\u4e8e\u73b0\u6709\u7684\u8c03\u67e5\u548c\u8def\u7ebf\u56fe\uff0c\u4e3a\u6784\u5efa\u53ef\u4fe1\u8d56\u7684\u81ea\u4e3b\u7cfb\u7edf\u63d0\u4f9b\u4e86\u65b0\u7684\u7814\u7a76\u65b9\u5411\u3002", "conclusion": "RV\u548cLLMs\u7684\u5171\u751f\u96c6\u6210\u6709\u671b\u5b9e\u73b0\u66f4\u53ef\u9760\u7684\u81ea\u4e3b\u7cfb\u7edf\uff0c\u9700\u8981\u8fdb\u4e00\u6b65\u7814\u7a76\u76f8\u5173\u6311\u6218\u548c\u8ba4\u8bc1\u5f71\u54cd\u3002"}}
{"id": "2511.14116", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2511.14116", "abs": "https://arxiv.org/abs/2511.14116", "authors": ["Ziyi Xu", "Zhiqiang Xie", "Swapnil Gandhi", "Christos Kozyrakis"], "title": "FailSafe: High-performance Resilient Serving", "comment": null, "summary": "Tensor parallelism (TP) enables large language models (LLMs) to scale inference efficiently across multiple GPUs, but its tight coupling makes systems fragile: a single GPU failure can halt execution, trigger costly KVCache recomputation, and introduce long-term compute and memory imbalance. We present FailSafe, a fault-tolerant TP serving system that sustains high performance under irregular GPU availability. FailSafe introduces three techniques to balance computation and memory across GPUs: (1) Cyclic KVCache Placement for uniform memory utilization, (2) Hybrid Attention combining tensor- and data-parallel attention to eliminate stragglers, and (3) Fine-Grained Load-Aware Routing to dynamically balance requests. It further employs proactive KVCache backup and on-demand weight recovery to avoid expensive recomputation and redundant data transfers. We implement these techniques in a lightweight serving engine compatible with existing LLM infrastructures. Evaluated on an 8xH100 DGX system with real-world fault traces and representative workloads, FailSafe achieves up to 2x higher throughput and two orders of magnitude lower recovery latency compared to standard fault handling approaches. Even with up to three GPU failures, FailSafe sustains high throughput and balanced utilization, demonstrating robust and efficient LLM serving under dynamic and unreliable hardware conditions.", "AI": {"tldr": "FailSafe\u662f\u4e00\u4e2a\u5bb9\u9519\u7684\u5f20\u91cf\u5e76\u884c(TP)\u670d\u52a1\u7cfb\u7edf\uff0c\u901a\u8fc7\u5faa\u73afKVCache\u653e\u7f6e\u3001\u6df7\u5408\u6ce8\u610f\u529b\u548c\u7ec6\u7c92\u5ea6\u8d1f\u8f7d\u611f\u77e5\u8def\u7531\u7b49\u6280\u672f\uff0c\u5728GPU\u6545\u969c\u65f6\u7ef4\u6301\u9ad8\u6027\u80fdLLM\u63a8\u7406\uff0c\u5b9e\u73b02\u500d\u541e\u5410\u91cf\u63d0\u5347\u548c\u4e24\u4e2a\u6570\u91cf\u7ea7\u7684\u6062\u590d\u5ef6\u8fdf\u964d\u4f4e\u3002", "motivation": "\u4f20\u7edf\u5f20\u91cf\u5e76\u884c(TP)\u5728LLM\u63a8\u7406\u4e2d\u5b58\u5728\u8106\u5f31\u6027\uff1a\u5355\u4e2aGPU\u6545\u969c\u4f1a\u5bfc\u81f4\u6267\u884c\u4e2d\u65ad\u3001\u89e6\u53d1\u6602\u8d35\u7684KVCache\u91cd\u8ba1\u7b97\uff0c\u5e76\u9020\u6210\u957f\u671f\u7684\u8ba1\u7b97\u548c\u5185\u5b58\u4e0d\u5e73\u8861\u3002", "method": "\u91c7\u7528\u5faa\u73afKVCache\u653e\u7f6e\u5b9e\u73b0\u5747\u5300\u5185\u5b58\u5229\u7528\uff0c\u6df7\u5408\u6ce8\u610f\u529b\u7ed3\u5408\u5f20\u91cf\u548c\u6570\u636e\u5e76\u884c\u6ce8\u610f\u529b\u6d88\u9664\u6162\u8282\u70b9\uff0c\u7ec6\u7c92\u5ea6\u8d1f\u8f7d\u611f\u77e5\u8def\u7531\u52a8\u6001\u5e73\u8861\u8bf7\u6c42\uff0c\u4ee5\u53ca\u4e3b\u52a8KVCache\u5907\u4efd\u548c\u6309\u9700\u6743\u91cd\u6062\u590d\u3002", "result": "\u57288xH100 DGX\u7cfb\u7edf\u4e0a\uff0cFailSafe\u76f8\u6bd4\u6807\u51c6\u5bb9\u9519\u65b9\u6cd5\u5b9e\u73b0\u9ad8\u8fbe2\u500d\u7684\u541e\u5410\u91cf\u63d0\u5347\u548c\u4e24\u4e2a\u6570\u91cf\u7ea7\u7684\u6062\u590d\u5ef6\u8fdf\u964d\u4f4e\uff0c\u5373\u4f7f\u6700\u591a\u4e09\u4e2aGPU\u6545\u969c\u4e5f\u80fd\u7ef4\u6301\u9ad8\u541e\u5410\u91cf\u548c\u5747\u8861\u5229\u7528\u3002", "conclusion": "FailSafe\u5c55\u793a\u4e86\u5728\u52a8\u6001\u4e0d\u53ef\u9760\u786c\u4ef6\u6761\u4ef6\u4e0b\u5b9e\u73b0\u9c81\u68d2\u9ad8\u6548LLM\u670d\u52a1\u7684\u80fd\u529b\uff0c\u4e3a\u5927\u89c4\u6a21LLM\u90e8\u7f72\u63d0\u4f9b\u4e86\u53ef\u9760\u7684\u5bb9\u9519\u89e3\u51b3\u65b9\u6848\u3002"}}
{"id": "2511.14528", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2511.14528", "abs": "https://arxiv.org/abs/2511.14528", "authors": ["Tatiane Ornelas", "Allysson Allex Ara\u00fajo", "J\u00falia Ara\u00fajo", "Marina Ara\u00fajo", "Bianca Trinkenreich", "Marcos Kalinowski"], "title": "LLM-Assisted Thematic Analysis: Opportunities, Limitations, and Recommendations", "comment": null, "summary": "[Context] Large Language Models (LLMs) are increasingly used to assist qualitative research in Software Engineering (SE), yet the methodological implications of this usage remain underexplored. Their integration into interpretive processes such as thematic analysis raises fundamental questions about rigor, transparency, and researcher agency. [Objective] This study investigates how experienced SE researchers conceptualize the opportunities, risks, and methodological implications of integrating LLMs into thematic analysis. [Method] A reflective workshop with 25 ISERN researchers guided participants through structured discussions of LLM-assisted open coding, theme generation, and theme reviewing, using color-coded canvases to document perceived opportunities, limitations, and recommendations. [Results] Participants recognized potential efficiency and scalability gains, but highlighted risks related to bias, contextual loss, reproducibility, and the rapid evolution of LLMs. They also emphasized the need for prompting literacy and continuous human oversight. [Conclusion] Findings portray LLMs as tools that can support, but not substitute, interpretive analysis. The study contributes to ongoing community reflections on how LLMs can responsibly enhance qualitative research in SE.", "AI": {"tldr": "\u672c\u7814\u7a76\u63a2\u8ba8\u4e86\u5728\u8f6f\u4ef6\u5de5\u7a0b\u5b9a\u6027\u7814\u7a76\u4e2d\u96c6\u6210\u5927\u8bed\u8a00\u6a21\u578b\u5230\u4e3b\u9898\u5206\u6790\u7684\u65b9\u6cd5\u8bba\u5f71\u54cd\uff0c\u53d1\u73b0LLMs\u53ef\u4f5c\u4e3a\u8f85\u52a9\u5de5\u5177\u4f46\u4e0d\u80fd\u66ff\u4ee3\u4eba\u7c7b\u89e3\u91ca\u6027\u5206\u6790\uff0c\u9700\u8981\u5173\u6ce8\u504f\u89c1\u3001\u4e0a\u4e0b\u6587\u4e22\u5931\u7b49\u98ce\u9669\u3002", "motivation": "\u968f\u7740LLMs\u8d8a\u6765\u8d8a\u591a\u5730\u7528\u4e8e\u8f85\u52a9\u8f6f\u4ef6\u5de5\u7a0b\u5b9a\u6027\u7814\u7a76\uff0c\u4f46\u5176\u5728\u89e3\u91ca\u6027\u8fc7\u7a0b\uff08\u5982\u4e3b\u9898\u5206\u6790\uff09\u4e2d\u7684\u65b9\u6cd5\u8bba\u5f71\u54cd\u4ecd\u672a\u88ab\u5145\u5206\u63a2\u7d22\uff0c\u9700\u8981\u7814\u7a76\u5176\u4e25\u8c28\u6027\u3001\u900f\u660e\u5ea6\u548c\u7814\u7a76\u8005\u80fd\u52a8\u6027\u7b49\u95ee\u9898\u3002", "method": "\u901a\u8fc7\u53cd\u601d\u6027\u7814\u8ba8\u4f1a\uff0c\u5f15\u5bfc25\u540dISERN\u7814\u7a76\u4eba\u5458\u8fdb\u884c\u7ed3\u6784\u5316\u8ba8\u8bba\uff0c\u4f7f\u7528\u5f69\u8272\u7f16\u7801\u753b\u5e03\u8bb0\u5f55\u5bf9LLM\u8f85\u52a9\u5f00\u653e\u5f0f\u7f16\u7801\u3001\u4e3b\u9898\u751f\u6210\u548c\u4e3b\u9898\u5ba1\u67e5\u7684\u611f\u77e5\u673a\u4f1a\u3001\u5c40\u9650\u6027\u548c\u5efa\u8bae\u3002", "result": "\u53c2\u4e0e\u8005\u8ba4\u8bc6\u5230\u6f5c\u5728\u7684\u6548\u7387\u548c\u53ef\u6269\u5c55\u6027\u6536\u76ca\uff0c\u4f46\u5f3a\u8c03\u4e86\u4e0e\u504f\u89c1\u3001\u4e0a\u4e0b\u6587\u4e22\u5931\u3001\u53ef\u91cd\u590d\u6027\u4ee5\u53caLLMs\u5feb\u901f\u6f14\u53d8\u76f8\u5173\u7684\u98ce\u9669\uff0c\u540c\u65f6\u5f3a\u8c03\u4e86\u63d0\u793a\u7d20\u517b\u548c\u6301\u7eed\u4eba\u5de5\u76d1\u7763\u7684\u5fc5\u8981\u6027\u3002", "conclusion": "\u7814\u7a76\u53d1\u73b0LLMs\u53ef\u4ee5\u4f5c\u4e3a\u652f\u6301\u4f46\u4e0d\u80fd\u66ff\u4ee3\u89e3\u91ca\u6027\u5206\u6790\u7684\u5de5\u5177\uff0c\u8be5\u7814\u7a76\u6709\u52a9\u4e8e\u793e\u533a\u6301\u7eed\u53cd\u601d\u5982\u4f55\u8d1f\u8d23\u4efb\u5730\u4f7f\u7528LLMs\u589e\u5f3a\u8f6f\u4ef6\u5de5\u7a0b\u4e2d\u7684\u5b9a\u6027\u7814\u7a76\u3002"}}
{"id": "2511.14124", "categories": ["cs.DC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2511.14124", "abs": "https://arxiv.org/abs/2511.14124", "authors": ["Sabiha Afroz", "Redwan Ibne Seraj Khan", "Hadeel Albahar", "Jingoo Han", "Ali R. Butt"], "title": "10Cache: Heterogeneous Resource-Aware Tensor Caching and Migration for LLM Training", "comment": "This paper accepted for presentation to the 16th ACM Symposium on Cloud Computing (SOCC'25)", "summary": "Training large language models (LLMs) in the cloud faces growing memory bottlenecks due to the limited capacity and high cost of GPUs. While GPU memory offloading to CPU and NVMe has made large-scale training more feasible, existing approaches suffer from high tensor migration latency and suboptimal device memory utilization, ultimately increasing training time and cloud costs. To address these challenges, we present 10Cache, a resource-aware tensor caching and migration system that accelerates LLM training by intelligently coordinating memory usage across GPU, CPU, and NVMe tiers. 10Cache profiles tensor execution order to construct prefetch policies, allocates memory buffers in pinned memory based on tensor size distributions, and reuses memory buffers to minimize allocation overhead.\n  Designed for cloud-scale deployments, 10Cache improves memory efficiency and reduces reliance on high-end GPUs. Across diverse LLM workloads, it achieves up to 2x speedup in training time, improves GPU cache hit rate by up to 86.6x, and increases CPU/GPU memory utilization by up to 2.15x and 1.33x, respectively, compared to state-of-the-art offloading methods. These results demonstrate that 10Cache is a practical and scalable solution for optimizing LLM training throughput and resource efficiency in cloud environments.", "AI": {"tldr": "10Cache\u662f\u4e00\u4e2a\u8d44\u6e90\u611f\u77e5\u7684\u5f20\u91cf\u7f13\u5b58\u548c\u8fc1\u79fb\u7cfb\u7edf\uff0c\u901a\u8fc7\u667a\u80fd\u534f\u8c03GPU\u3001CPU\u548cNVMe\u5c42\u7ea7\u7684\u5185\u5b58\u4f7f\u7528\u6765\u52a0\u901f\u5927\u8bed\u8a00\u6a21\u578b\u8bad\u7ec3\uff0c\u89e3\u51b3\u4e86\u73b0\u6709\u65b9\u6cd5\u7684\u9ad8\u5f20\u91cf\u8fc1\u79fb\u5ef6\u8fdf\u548c\u8bbe\u5907\u5185\u5b58\u5229\u7528\u7387\u4f4e\u7684\u95ee\u9898\u3002", "motivation": "\u4e91\u7aef\u8bad\u7ec3\u5927\u8bed\u8a00\u6a21\u578b\u9762\u4e34GPU\u5185\u5b58\u74f6\u9888\uff0c\u73b0\u6709GPU\u5185\u5b58\u5378\u8f7d\u65b9\u6cd5\u5b58\u5728\u9ad8\u5f20\u91cf\u8fc1\u79fb\u5ef6\u8fdf\u548c\u8bbe\u5907\u5185\u5b58\u5229\u7528\u7387\u4f4e\u7684\u95ee\u9898\uff0c\u5bfc\u81f4\u8bad\u7ec3\u65f6\u95f4\u589e\u52a0\u548c\u4e91\u6210\u672c\u4e0a\u5347\u3002", "method": "10Cache\u901a\u8fc7\u5206\u6790\u5f20\u91cf\u6267\u884c\u987a\u5e8f\u6784\u5efa\u9884\u53d6\u7b56\u7565\uff0c\u57fa\u4e8e\u5f20\u91cf\u5927\u5c0f\u5206\u5e03\u5728\u56fa\u5b9a\u5185\u5b58\u4e2d\u5206\u914d\u5185\u5b58\u7f13\u51b2\u533a\uff0c\u5e76\u91cd\u7528\u5185\u5b58\u7f13\u51b2\u533a\u4ee5\u51cf\u5c11\u5206\u914d\u5f00\u9500\u3002", "result": "\u5728\u591a\u6837\u5316LLM\u5de5\u4f5c\u8d1f\u8f7d\u4e2d\uff0c10Cache\u5b9e\u73b0\u4e86\u9ad8\u8fbe2\u500d\u7684\u8bad\u7ec3\u52a0\u901f\uff0cGPU\u7f13\u5b58\u547d\u4e2d\u7387\u63d0\u5347\u9ad8\u8fbe86.6\u500d\uff0cCPU/GPU\u5185\u5b58\u5229\u7528\u7387\u5206\u522b\u63d0\u9ad82.15\u500d\u548c1.33\u500d\u3002", "conclusion": "10Cache\u662f\u4f18\u5316\u4e91\u7aefLLM\u8bad\u7ec3\u541e\u5410\u91cf\u548c\u8d44\u6e90\u6548\u7387\u7684\u5b9e\u7528\u4e14\u53ef\u6269\u5c55\u7684\u89e3\u51b3\u65b9\u6848\u3002"}}
{"id": "2511.14618", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2511.14618", "abs": "https://arxiv.org/abs/2511.14618", "authors": ["Severin Kohler", "Jordi Piera Jim\u00e9nez", "Michael Anywar", "Lars Fuhrmann", "Heather Leslie", "Maximilian Meixner", "Julian Sa\u00df", "Florian K\u00e4rcher", "Diego Bosc\u00e1", "Birger Haarbrandt", "Michael Marschollek", "Roland Eils"], "title": "FHIRconnect: Towards a seamless integration of openEHR and FHIR", "comment": "27 pages, 4 figures", "summary": "Healthcare interoperability between openEHR and HL7 FHIR remains challenging due to fundamental differences in their data modeling approaches and the absence of standardized transformation mechanisms. This paper presents FHIRconnect, a novel domain-specific language and open-source transformation engine that enables standardized, bidirectional data exchange between openEHR and FHIR. Our approach addresses critical interoperability gaps through a triple-layered architecture that achieves 65% mapping reuse across projects by leveraging international archetype-based foundations while supporting local customizations. Using this framework, FHIRconnect successfully mapped 24 international archetypes to 15 FHIR profiles across seven clinical domains. Key contributions include the first comprehensive DSL for openEHR-FHIR transformation with a formal specification, an open-source execution engine (openFHIR), and an accessible mapping library covering high-impact clinical archetypes. Together, these components establish the technical basis for community-driven mapping standardization, reducing reliance on custom ETL solutions and advancing syntactic and semantic interoperability in healthcare IT systems built on open standards.", "AI": {"tldr": "FHIRconnect\u662f\u4e00\u4e2a\u7528\u4e8eopenEHR\u548cHL7 FHIR\u4e4b\u95f4\u53cc\u5411\u6570\u636e\u4ea4\u6362\u7684\u9886\u57df\u7279\u5b9a\u8bed\u8a00\u548c\u5f00\u6e90\u8f6c\u6362\u5f15\u64ce\uff0c\u901a\u8fc7\u4e09\u5c42\u67b6\u6784\u5b9e\u73b065%\u7684\u6620\u5c04\u590d\u7528\uff0c\u6210\u529f\u6620\u5c04\u4e8624\u4e2a\u56fd\u9645\u539f\u578b\u523015\u4e2aFHIR\u914d\u7f6e\u6587\u4ef6\u3002", "motivation": "\u89e3\u51b3openEHR\u548cHL7 FHIR\u4e4b\u95f4\u7531\u4e8e\u6570\u636e\u5efa\u6a21\u65b9\u6cd5\u6839\u672c\u5dee\u5f02\u548c\u7f3a\u4e4f\u6807\u51c6\u5316\u8f6c\u6362\u673a\u5236\u800c\u5bfc\u81f4\u7684\u533b\u7597\u4e92\u64cd\u4f5c\u6027\u6311\u6218\u3002", "method": "\u5f00\u53d1\u4e86FHIRconnect\u9886\u57df\u7279\u5b9a\u8bed\u8a00\u548c\u5f00\u6e90\u8f6c\u6362\u5f15\u64ce\uff0c\u91c7\u7528\u4e09\u5c42\u67b6\u6784\uff0c\u5229\u7528\u56fd\u9645\u539f\u578b\u57fa\u7840\u652f\u6301\u672c\u5730\u5b9a\u5236\u5316\uff0c\u5b9e\u73b0\u6807\u51c6\u5316\u53cc\u5411\u6570\u636e\u4ea4\u6362\u3002", "result": "\u6210\u529f\u6620\u5c0424\u4e2a\u56fd\u9645\u539f\u578b\u523015\u4e2aFHIR\u914d\u7f6e\u6587\u4ef6\uff0c\u8986\u76d6\u4e03\u4e2a\u4e34\u5e8a\u9886\u57df\uff0c\u5efa\u7acb\u4e86\u793e\u533a\u9a71\u52a8\u7684\u6620\u5c04\u6807\u51c6\u5316\u6280\u672f\u57fa\u7840\u3002", "conclusion": "FHIRconnect\u51cf\u5c11\u4e86\u81ea\u5b9a\u4e49ETL\u89e3\u51b3\u65b9\u6848\u7684\u4f9d\u8d56\uff0c\u63a8\u8fdb\u4e86\u57fa\u4e8e\u5f00\u653e\u6807\u51c6\u7684\u533b\u7597IT\u7cfb\u7edf\u7684\u8bed\u6cd5\u548c\u8bed\u4e49\u4e92\u64cd\u4f5c\u6027\u3002"}}
{"id": "2511.14450", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2511.14450", "abs": "https://arxiv.org/abs/2511.14450", "authors": ["Mulei Ma", "Minrui Xu", "Zihan Chen", "Yang Yang", "Tony Q. S. Quek"], "title": "Hyperion: Hierarchical Scheduling for Parallel LLM Acceleration in Multi-tier Networks", "comment": null, "summary": "Large Language Models (LLMs) are increasingly executed across edge, fog, and cloud tiers where limited GPU memory, heterogeneous compute, and variable inter-tier bandwidth jointly constrain deployment and motivate model partitioning and request scheduling. In this setting, achieving low end-to-end latency is governed not only by where a model is deployed (inter-tier model partitioning) but also by how incoming requests are scheduled (intra-tier task scheduling) across heterogeneous nodes. These two problems are tightly coupled, as a suboptimal scheduler can negate the benefits of a good partition, and vice versa. In this paper, we propose Hyperion, a hierarchical two-stage framework that jointly optimizes partitioning and scheduling to minimize end-to-end latency for pipelined LLM inference in multi-tier networks, balancing compute and memory across tiers while introducing negligible runtime overhead and requiring no model retraining. Motivated by the observation that partition choices evolve on slower timescales than request arrivals, Stage 1 performs offline, inter-tier partitioning via a Binary Search with Dynamic Programming (BSDP) procedure to produce balanced stage times under tier capacity and memory constraints; to adapt to time-varying load, Stage 2 performs online, intra-tier scheduling with a lightweight Adaptive Real-time Task Scheduling (ARTS) algorithm that maps each request to the best available node using real-time estimates of queue length and effective capacity. Experimental results on multi-tier inference tasks demonstrate that Hyperion significantly reduces end-to-end latency by up to 52.1\\% and 31.2\\%, with the Phi-3-medium model, compared to the GPipe and HEFT baselines, respectively. Furthermore, Hyperion shows superior scalability in long-sequence generation, maintaining a 44.5\\% lower latency than GPipe and achieving higher GPU utilization.", "AI": {"tldr": "Hyperion\u662f\u4e00\u4e2a\u7528\u4e8e\u591a\u5c42\u7ea7\u7f51\u7edc\u4e2d\u6d41\u6c34\u7ebfLLM\u63a8\u7406\u7684\u4e24\u9636\u6bb5\u6846\u67b6\uff0c\u901a\u8fc7\u8054\u5408\u4f18\u5316\u6a21\u578b\u5206\u533a\u548c\u4efb\u52a1\u8c03\u5ea6\u6765\u6700\u5c0f\u5316\u7aef\u5230\u7aef\u5ef6\u8fdf\u3002", "motivation": "LLM\u5728\u8fb9\u7f18\u3001\u96fe\u548c\u4e91\u5c42\u90e8\u7f72\u65f6\u9762\u4e34GPU\u5185\u5b58\u9650\u5236\u3001\u5f02\u6784\u8ba1\u7b97\u548c\u53ef\u53d8\u5e26\u5bbd\u7684\u6311\u6218\uff0c\u9700\u8981\u5e73\u8861\u6a21\u578b\u5206\u533a\u548c\u8bf7\u6c42\u8c03\u5ea6\u6765\u964d\u4f4e\u5ef6\u8fdf\u3002", "method": "\u91c7\u7528\u5206\u5c42\u4e24\u9636\u6bb5\u65b9\u6cd5\uff1a\u7b2c\u4e00\u9636\u6bb5\u901a\u8fc7\u4e8c\u5206\u641c\u7d22\u548c\u52a8\u6001\u89c4\u5212\u8fdb\u884c\u79bb\u7ebf\u5206\u533a\uff1b\u7b2c\u4e8c\u9636\u6bb5\u4f7f\u7528\u81ea\u9002\u5e94\u5b9e\u65f6\u4efb\u52a1\u8c03\u5ea6\u7b97\u6cd5\u8fdb\u884c\u5728\u7ebf\u8c03\u5ea6\u3002", "result": "\u5728Phi-3-medium\u6a21\u578b\u4e0a\uff0c\u76f8\u6bd4GPipe\u548cHEFT\u57fa\u7ebf\uff0cHyperion\u5206\u522b\u5c06\u7aef\u5230\u7aef\u5ef6\u8fdf\u964d\u4f4e\u4e8652.1%\u548c31.2%\uff0c\u5e76\u5728\u957f\u5e8f\u5217\u751f\u6210\u4e2d\u4fdd\u630144.5%\u7684\u5ef6\u8fdf\u4f18\u52bf\u3002", "conclusion": "Hyperion\u80fd\u591f\u6709\u6548\u5e73\u8861\u591a\u5c42\u7ea7\u7f51\u7edc\u4e2d\u7684\u8ba1\u7b97\u548c\u5185\u5b58\u8d44\u6e90\uff0c\u663e\u8457\u964d\u4f4eLLM\u63a8\u7406\u5ef6\u8fdf\uff0c\u4e14\u65e0\u9700\u6a21\u578b\u91cd\u8bad\u7ec3\uff0c\u8fd0\u884c\u65f6\u5f00\u9500\u53ef\u5ffd\u7565\u3002"}}
{"id": "2511.14456", "categories": ["cs.DC", "cs.AI"], "pdf": "https://arxiv.org/pdf/2511.14456", "abs": "https://arxiv.org/abs/2511.14456", "authors": ["Fabian Stricker", "David Bermbach", "Christian Zirpins"], "title": "Analyzing the Impact of Participant Failures in Cross-Silo Federated Learning", "comment": "Accepted for publication in 3rd IEEE International Conference on Federated Learning Applications and Technologies (FLTA2025)", "summary": "Federated learning (FL) is a new paradigm for training machine learning (ML) models without sharing data. While applying FL in cross-silo scenarios, where organizations collaborate, it is necessary that the FL system is reliable; however, participants can fail due to various reasons (e.g., communication issues or misconfigurations). In order to provide a reliable system, it is necessary to analyze the impact of participant failures. While this problem received attention in cross-device FL where mobile devices with limited resources participate, there is comparatively little research in cross-silo FL.\n  Therefore, we conduct an extensive study for analyzing the impact of participant failures on the model quality in the context of inter-organizational cross-silo FL with few participants. In our study, we focus on analyzing generally influential factors such as the impact of the timing and the data as well as the impact on the evaluation, which is important for deciding, if the model should be deployed. We show that under high skews the evaluation is optimistic and hides the real impact. Furthermore, we demonstrate that the timing impacts the quality of the trained model. Our results offer insights for researchers and software architects aiming to build robust FL systems.", "AI": {"tldr": "\u672c\u6587\u5206\u6790\u4e86\u8de8\u7ec4\u7ec7\u8054\u90a6\u5b66\u4e60\u4e2d\u53c2\u4e0e\u8005\u6545\u969c\u5bf9\u6a21\u578b\u8d28\u91cf\u7684\u5f71\u54cd\uff0c\u91cd\u70b9\u5173\u6ce8\u6545\u969c\u65f6\u673a\u3001\u6570\u636e\u5206\u5e03\u548c\u8bc4\u4f30\u65b9\u6cd5\u7b49\u56e0\u7d20\u3002", "motivation": "\u8054\u90a6\u5b66\u4e60\u5728\u8de8\u7ec4\u7ec7\u573a\u666f\u4e2d\u9700\u8981\u53ef\u9760\u7cfb\u7edf\uff0c\u4f46\u53c2\u4e0e\u8005\u53ef\u80fd\u56e0\u5404\u79cd\u539f\u56e0\u6545\u969c\u3002\u76ee\u524d\u5bf9\u8de8\u7ec4\u7ec7\u8054\u90a6\u5b66\u4e60\u4e2d\u53c2\u4e0e\u8005\u6545\u969c\u5f71\u54cd\u7684\u7814\u7a76\u8f83\u5c11\uff0c\u9700\u8981\u6df1\u5165\u5206\u6790\u3002", "method": "\u901a\u8fc7\u5e7f\u6cdb\u7814\u7a76\u5206\u6790\u8de8\u7ec4\u7ec7\u8054\u90a6\u5b66\u4e60\u4e2d\u53c2\u4e0e\u8005\u6545\u969c\u5bf9\u6a21\u578b\u8d28\u91cf\u7684\u5f71\u54cd\uff0c\u91cd\u70b9\u5173\u6ce8\u6545\u969c\u65f6\u673a\u3001\u6570\u636e\u5206\u5e03\u548c\u8bc4\u4f30\u65b9\u6cd5\u7b49\u5173\u952e\u56e0\u7d20\u3002", "result": "\u7814\u7a76\u8868\u660e\uff0c\u5728\u9ad8\u6570\u636e\u504f\u659c\u60c5\u51b5\u4e0b\u8bc4\u4f30\u7ed3\u679c\u8fc7\u4e8e\u4e50\u89c2\uff0c\u63a9\u76d6\u4e86\u771f\u5b9e\u5f71\u54cd\uff1b\u6545\u969c\u65f6\u673a\u5bf9\u8bad\u7ec3\u6a21\u578b\u8d28\u91cf\u6709\u663e\u8457\u5f71\u54cd\u3002", "conclusion": "\u7814\u7a76\u7ed3\u679c\u4e3a\u6784\u5efa\u9c81\u68d2\u8054\u90a6\u5b66\u4e60\u7cfb\u7edf\u7684\u7814\u7a76\u4eba\u5458\u548c\u8f6f\u4ef6\u67b6\u6784\u5e08\u63d0\u4f9b\u4e86\u91cd\u8981\u89c1\u89e3\u3002"}}
{"id": "2511.14608", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2511.14608", "abs": "https://arxiv.org/abs/2511.14608", "authors": ["Dave Dice", "Alex Kogan"], "title": "Hapax Locks : Value-Based Mutual Exclusion", "comment": null, "summary": "We present Hapax Locks, a novel locking algorithm that is simple, enjoys constant-time arrival and unlock paths, provides FIFO admission order, and which is also space efficient and generates relatively little coherence traffic under contention in the common case. Hapax Locks offer performance (both latency and scalability) that is comparable with the best state of the art locks, while at the same time Hapax Locks impose fewer constraints and dependencies on the ambient runtime environment, making them particularly easy to integrate or retrofit into existing systems or under existing application programming interfaces Of particular note, no pointers shift or escape ownership between threads in our algorithm.", "AI": {"tldr": "Hapax Locks\u662f\u4e00\u79cd\u65b0\u9896\u7684\u9501\u7b97\u6cd5\uff0c\u5177\u6709\u6052\u5b9a\u65f6\u95f4\u5230\u8fbe\u548c\u89e3\u9501\u8def\u5f84\u3001FIFO\u51c6\u5165\u987a\u5e8f\u3001\u7a7a\u95f4\u6548\u7387\u9ad8\u3001\u5728\u7ade\u4e89\u60c5\u51b5\u4e0b\u4ea7\u751f\u8f83\u5c11\u4e00\u81f4\u6027\u6d41\u91cf\u7b49\u4f18\u70b9\u3002", "motivation": "\u5f00\u53d1\u4e00\u79cd\u6027\u80fd\u4e0e\u6700\u5148\u8fdb\u9501\u7b97\u6cd5\u76f8\u5f53\uff0c\u4f46\u5bf9\u8fd0\u884c\u65f6\u73af\u5883\u7ea6\u675f\u66f4\u5c11\u3001\u66f4\u6613\u4e8e\u96c6\u6210\u5230\u73b0\u6709\u7cfb\u7edf\u4e2d\u7684\u9501\u7b97\u6cd5\u3002", "method": "\u63d0\u51faHapax Locks\u7b97\u6cd5\uff0c\u8be5\u7b97\u6cd5\u5728\u7ebf\u7a0b\u95f4\u4e0d\u8f6c\u79fb\u6307\u9488\u6240\u6709\u6743\uff0c\u7b80\u5316\u4e86\u5b9e\u73b0\u5e76\u51cf\u5c11\u4e86\u73af\u5883\u4f9d\u8d56\u3002", "result": "Hapax Locks\u5728\u5ef6\u8fdf\u548c\u53ef\u6269\u5c55\u6027\u65b9\u9762\u4e0e\u6700\u4f73\u9501\u7b97\u6cd5\u6027\u80fd\u76f8\u5f53\uff0c\u540c\u65f6\u66f4\u6613\u4e8e\u96c6\u6210\u5230\u73b0\u6709\u7cfb\u7edf\u6216API\u4e2d\u3002", "conclusion": "Hapax Locks\u662f\u4e00\u79cd\u7b80\u5355\u9ad8\u6548\u3001\u6613\u4e8e\u96c6\u6210\u7684\u9501\u7b97\u6cd5\uff0c\u7279\u522b\u9002\u5408\u5728\u73b0\u6709\u7cfb\u7edf\u4e2d\u4f7f\u7528\u3002"}}
{"id": "2511.14617", "categories": ["cs.DC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2511.14617", "abs": "https://arxiv.org/abs/2511.14617", "authors": ["Ruoyu Qin", "Weiran He", "Weixiao Huang", "Yangkun Zhang", "Yikai Zhao", "Bo Pang", "Xinran Xu", "Yingdi Shan", "Yongwei Wu", "Mingxing Zhang"], "title": "Seer: Online Context Learning for Fast Synchronous LLM Reinforcement Learning", "comment": "16 pages, 12 figures, 6 tables", "summary": "Reinforcement Learning (RL) has become critical for advancing modern Large Language Models (LLMs), yet existing synchronous RL systems face severe performance bottlenecks. The rollout phase, which dominates end-to-end iteration time, suffers from substantial long-tail latency and poor resource utilization due to inherent workload imbalance. We present Seer, a novel online context learning system that addresses these challenges by exploiting previously overlooked similarities in output lengths and generation patterns among requests sharing the same prompt. Seer introduces three key techniques: divided rollout for dynamic load balancing, context-aware scheduling, and adaptive grouped speculative decoding. Together, these mechanisms substantially reduce long-tail latency and improve resource efficiency during rollout. Evaluations on production-grade RL workloads demonstrate that Seer improves end-to-end rollout throughput by 74% to 97% and reduces long-tail latency by 75% to 93% compared to state-of-the-art synchronous RL systems, significantly accelerating RL training iterations.", "AI": {"tldr": "Seer\u662f\u4e00\u4e2a\u5728\u7ebf\u4e0a\u4e0b\u6587\u5b66\u4e60\u7cfb\u7edf\uff0c\u901a\u8fc7\u5229\u7528\u5171\u4eab\u76f8\u540c\u63d0\u793a\u7684\u8bf7\u6c42\u5728\u8f93\u51fa\u957f\u5ea6\u548c\u751f\u6210\u6a21\u5f0f\u4e0a\u7684\u76f8\u4f3c\u6027\uff0c\u89e3\u51b3\u4e86\u540c\u6b65\u5f3a\u5316\u5b66\u4e60\u7cfb\u7edf\u4e2d\u7684\u6027\u80fd\u74f6\u9888\u95ee\u9898\u3002", "motivation": "\u73b0\u6709\u7684\u540c\u6b65\u5f3a\u5316\u5b66\u4e60\u7cfb\u7edf\u5728rollout\u9636\u6bb5\u9762\u4e34\u4e25\u91cd\u7684\u6027\u80fd\u74f6\u9888\uff0c\u5b58\u5728\u663e\u8457\u7684\u957f\u5c3e\u5ef6\u8fdf\u548c\u8d44\u6e90\u5229\u7528\u7387\u4f4e\u7684\u95ee\u9898\uff0c\u4e3b\u8981\u7531\u4e8e\u5de5\u4f5c\u8d1f\u8f7d\u4e0d\u5e73\u8861\u5bfc\u81f4\u3002", "method": "Seer\u5f15\u5165\u4e86\u4e09\u9879\u5173\u952e\u6280\u672f\uff1a\u5206\u5272rollout\u5b9e\u73b0\u52a8\u6001\u8d1f\u8f7d\u5747\u8861\u3001\u4e0a\u4e0b\u6587\u611f\u77e5\u8c03\u5ea6\u3001\u4ee5\u53ca\u81ea\u9002\u5e94\u5206\u7ec4\u63a8\u6d4b\u89e3\u7801\uff0c\u8fd9\u4e9b\u673a\u5236\u5171\u540c\u51cf\u5c11\u4e86\u957f\u5c3e\u5ef6\u8fdf\u5e76\u63d0\u9ad8\u4e86\u8d44\u6e90\u6548\u7387\u3002", "result": "\u5728\u751f\u4ea7\u7ea7\u5f3a\u5316\u5b66\u4e60\u5de5\u4f5c\u8d1f\u8f7d\u4e0a\u7684\u8bc4\u4f30\u8868\u660e\uff0c\u4e0e\u6700\u5148\u8fdb\u7684\u540c\u6b65\u5f3a\u5316\u5b66\u4e60\u7cfb\u7edf\u76f8\u6bd4\uff0cSeer\u5c06\u7aef\u5230\u7aefrollout\u541e\u5410\u91cf\u63d0\u9ad8\u4e8674%\u523097%\uff0c\u5e76\u5c06\u957f\u5c3e\u5ef6\u8fdf\u964d\u4f4e\u4e8675%\u523093%\u3002", "conclusion": "Seer\u7cfb\u7edf\u663e\u8457\u52a0\u901f\u4e86\u5f3a\u5316\u5b66\u4e60\u8bad\u7ec3\u8fed\u4ee3\uff0c\u901a\u8fc7\u5229\u7528\u8bf7\u6c42\u95f4\u7684\u76f8\u4f3c\u6027\u6709\u6548\u89e3\u51b3\u4e86\u540c\u6b65\u5f3a\u5316\u5b66\u4e60\u7cfb\u7edf\u4e2d\u7684\u6027\u80fd\u74f6\u9888\u95ee\u9898\u3002"}}
{"id": "2509.12443", "categories": ["cs.SE", "cs.AI", "cs.DC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.12443", "abs": "https://arxiv.org/abs/2509.12443", "authors": ["Sparsh Gupta", "Kamalavasan Kamalakkannan", "Maxim Moraru", "Galen Shipman", "Patrick Diehl"], "title": "From Legacy Fortran to Portable Kokkos: An Autonomous Agentic AI Workflow", "comment": "12 pages, 6 figures, 7 tables", "summary": "Scientific applications continue to rely on legacy Fortran codebases originally developed for homogeneous, CPU-based systems. As High-Performance Computing (HPC) shifts toward heterogeneous GPU-accelerated architectures, many accelerators lack native Fortran bindings, creating an urgent need to modernize legacy codes for portability. Frameworks like Kokkos provide performance portability and a single-source C++ abstraction, but manual Fortran-to-Kokkos porting demands significant expertise and time. Large language models (LLMs) have shown promise in source-to-source code generation, yet their use in fully autonomous workflows for translating and optimizing parallel code remains largely unexplored, especially for performance portability across diverse hardware. This paper presents an agentic AI workflow where specialized LLM \"agents\" collaborate to translate, validate, compile, run, test, debug, and optimize Fortran kernels into portable Kokkos C++ programs. Results show the pipeline modernizes a range of benchmark kernels, producing performance-portable Kokkos codes across hardware partitions. Paid OpenAI models such as GPT-5 and o4-mini-high executed the workflow for only a few U.S. dollars, generating optimized codes that surpassed Fortran baselines, whereas open-source models like Llama4-Maverick often failed to yield functional codes. This work demonstrates the feasibility of agentic AI for Fortran-to-Kokkos transformation and offers a pathway for autonomously modernizing legacy scientific applications to run portably and efficiently on diverse supercomputers. It further highlights the potential of LLM-driven agentic systems to perform structured, domain-specific reasoning tasks in scientific and systems-oriented applications.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u57fa\u4e8e\u667a\u80fdAI\u4ee3\u7406\u7684\u5de5\u4f5c\u6d41\uff0c\u901a\u8fc7\u4e13\u95e8\u7684LLM\u4ee3\u7406\u534f\u4f5c\u5c06Fortran\u5185\u6838\u8f6c\u6362\u4e3a\u53ef\u79fb\u690d\u7684Kokkos C++\u7a0b\u5e8f\uff0c\u5b9e\u73b0\u4e86\u5728\u5f02\u6784GPU\u67b6\u6784\u4e0a\u7684\u6027\u80fd\u53ef\u79fb\u690d\u6027\u3002", "motivation": "\u968f\u7740HPC\u5411\u5f02\u6784GPU\u52a0\u901f\u67b6\u6784\u8f6c\u53d8\uff0c\u8bb8\u591a\u52a0\u901f\u5668\u7f3a\u4e4f\u539f\u751fFortran\u7ed1\u5b9a\uff0c\u9700\u8981\u5c06\u4f20\u7edfFortran\u4ee3\u7801\u73b0\u4ee3\u5316\u4ee5\u5b9e\u73b0\u53ef\u79fb\u690d\u6027\u3002\u867d\u7136Kokkos\u6846\u67b6\u63d0\u4f9b\u4e86\u6027\u80fd\u53ef\u79fb\u690d\u6027\uff0c\u4f46\u624b\u52a8\u79fb\u690d\u9700\u8981\u5927\u91cf\u4e13\u4e1a\u77e5\u8bc6\u548c\u65f6\u95f4\u3002", "method": "\u4f7f\u7528\u4e13\u95e8\u7684LLM\u4ee3\u7406\u534f\u4f5c\u5de5\u4f5c\u6d41\uff0c\u5305\u62ec\u7ffb\u8bd1\u3001\u9a8c\u8bc1\u3001\u7f16\u8bd1\u3001\u8fd0\u884c\u3001\u6d4b\u8bd5\u3001\u8c03\u8bd5\u548c\u4f18\u5316Fortran\u5185\u6838\u4e3a\u53ef\u79fb\u690d\u7684Kokkos C++\u7a0b\u5e8f\u3002", "result": "\u8be5\u6d41\u6c34\u7ebf\u6210\u529f\u73b0\u4ee3\u5316\u4e86\u4e00\u7cfb\u5217\u57fa\u51c6\u5185\u6838\uff0c\u5728\u786c\u4ef6\u5206\u533a\u4e0a\u751f\u6210\u4e86\u6027\u80fd\u53ef\u79fb\u690d\u7684Kokkos\u4ee3\u7801\u3002\u4ed8\u8d39OpenAI\u6a21\u578b\u4ec5\u9700\u51e0\u7f8e\u5143\u5c31\u80fd\u6267\u884c\u5de5\u4f5c\u6d41\uff0c\u751f\u6210\u7684\u4f18\u5316\u4ee3\u7801\u8d85\u8d8a\u4e86Fortran\u57fa\u7ebf\uff0c\u800c\u5f00\u6e90\u6a21\u578b\u901a\u5e38\u65e0\u6cd5\u751f\u6210\u529f\u80fd\u4ee3\u7801\u3002", "conclusion": "\u8fd9\u9879\u5de5\u4f5c\u8bc1\u660e\u4e86\u667a\u80fdAI\u4ee3\u7406\u5728Fortran\u5230Kokkos\u8f6c\u6362\u4e2d\u7684\u53ef\u884c\u6027\uff0c\u4e3a\u81ea\u4e3b\u73b0\u4ee3\u5316\u4f20\u7edf\u79d1\u5b66\u5e94\u7528\u7a0b\u5e8f\u63d0\u4f9b\u4e86\u9014\u5f84\uff0c\u4f7f\u5176\u80fd\u591f\u5728\u4e0d\u540c\u8d85\u7ea7\u8ba1\u7b97\u673a\u4e0a\u53ef\u79fb\u690d\u4e14\u9ad8\u6548\u8fd0\u884c\u3002"}}
